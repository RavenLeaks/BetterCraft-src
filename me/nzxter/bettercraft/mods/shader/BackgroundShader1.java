/*    */ package me.nzxter.bettercraft.mods.shader;
/*    */ 
/*    */ public class BackgroundShader1 {
/*  4 */   public static String Universes = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n \r\nuniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n\r\n#define iterations 10\r\n#define formuparam2 0.79\r\n \r\n#define volsteps 5\r\n#define stepsize 0.290\r\n \r\n#define zoom 0.800\r\n#define tile   0.850\r\n#define speed2  0.10\r\n\r\n#define brightness 0.002\r\n#define darkmatter 0.500\r\n#define distfading 0.560\r\n#define saturation 0.700\r\n\r\n#define transverseSpeed zoom*0.1\r\n#define cloud 0.01\r\n \r\nfloat triangle(float x, float a) { \r\n\tfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;\r\n\treturn output2;\r\n}\r\n \r\nfloat field(in vec3 p) {\t\r\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = 0.;\r\n\tfloat prev = 0.;\r\n\tfloat tw = 0.;\t\r\n\r\n\tfor (int i = 0; i < 6; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(time*0.7 + 2.0), -1.1+0.3*cos(time*0.3));\r\n\t\tfloat w = exp(-float(i) / 7.);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0., 5. * accum / tw - .7);\r\n}\r\n\r\nvoid main() {   \r\n     \tvec2 uv2 = 2. * gl_FragCoord.xy / vec2(512) - 1.;\r\n\tvec2 uvs = uv2 * vec2(512)  / 512.;\r\n\t\r\n\tfloat time2 = time;               \r\n        float speed = speed2;\r\n        speed = .01 * cos(time2*0.02 + 3.1415926/4.0);          \r\n\t//speed = 0.0;\t\r\n    \tfloat formuparam = formuparam2;\r\n\t\r\n    \t//get coords and direction\t\r\n\tvec2 uv = uvs;\t\t       \r\n\t//mouse rotation\r\n\tfloat a_xz = 0.9;\r\n\tfloat a_yz = -.6;\r\n\tfloat a_xy = 0.9 + time*0.08;\t\r\n\t\r\n\tmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\t\r\n\tmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\t\t\r\n\tmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\r\n\t\r\n\r\n\tfloat v2 =1.0;\t\r\n\tvec3 dir=vec3(uv*zoom,1.); \r\n\tvec3 from=vec3(0.0, 0.0,0.0);                               \r\n        from.x -= 5.0*(1.0-1.0);\r\n        from.y -= 5.0*(1.0-0.7);\r\n               \r\n               \r\n\tvec3 forward = vec3(0.,0.,1.);   \r\n\tfrom.x += transverseSpeed*(1.0)*cos(0.01*time) + 0.001*time;\r\n\tfrom.y += transverseSpeed*(1.0)*sin(0.01*time) +0.001*time;\r\n\tfrom.z += 0.003*time;\t\r\n\t\r\n\tdir.xy*=rot_xy;\r\n\tforward.xy *= rot_xy;\r\n\tdir.xz*=rot_xz;\r\n\tforward.xz *= rot_xz;\t\r\n\tdir.yz*= rot_yz;\r\n\tforward.yz *= rot_yz;\r\n\t\r\n\tfrom.xy*=-rot_xy;\r\n\tfrom.xz*=rot_xz;\r\n\tfrom.yz*= rot_yz;\r\n\t \r\n\t\r\n\t//zoom\r\n\tfloat zooom = (time2-3311.)*speed;\r\n\tfrom += forward* zooom;\r\n\tfloat sampleShift = mod( zooom, stepsize );\r\n\t \r\n\tfloat zoffset = -sampleShift;\r\n\tsampleShift /= stepsize; // make from 0 to 1\r\n\t\r\n\t//volumetric rendering\r\n\tfloat s=0.24;\r\n\tfloat s3 = s + stepsize/2.0;\r\n\tvec3 v=vec3(0.);\r\n\tfloat t3 = 0.0;\t\r\n\t\r\n\tvec3 backCol2 = vec3(0.);\r\n\tfor (int r=0; r<volsteps; r++) {\r\n\t\tvec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\r\n\t\tvec3 p3=from+(s3+zoffset)*dir;// + vec3(0.,0.,zoffset);\r\n\t\t\r\n\t\tp2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold\r\n\t\tp3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\t\t\r\n\t\t#ifdef cloud\r\n\t\tt3 = field(p3);\r\n\t\t#endif\r\n\t\t\r\n\t\tfloat pa,a=pa=0.;\r\n\t\tfor (int i=0; i<iterations; i++) {\r\n\t\t\tp2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula\r\n\t\t\t//p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise\r\n\t\t\tfloat D = abs(length(p2)-pa); // absolute sum of average change\r\n\t\t\ta += i > 7 ? min( 12., D) : D;\r\n\t\t\tpa=length(p2);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t//float dm=max(0.,darkmatter-a*a*.001); //dark matter\r\n\t\ta*=a*a; // add contrast\r\n\t\t//if (r>3) fade*=1.-dm; // dark matter, don't render near\r\n\t\t// brightens stuff up a bit\r\n\t\tfloat s1 = s+zoffset;\r\n\t\t// need closed form expression for this, now that we shift samples\r\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\t\t\r\n\t\t//t3 += fade;\t\t\r\n\t\tv+=fade;\r\n\t       \t//backCol2 -= fade;\r\n\r\n\t\t// fade out samples as they approach the camera\r\n\t\tif( r == 0 )\r\n\t\t\tfade *= (1. - (sampleShift));\r\n\t\t// fade in samples as they approach from the distance\r\n\t\tif( r == volsteps-1 )\r\n\t\t\tfade *= sampleShift;\r\n\t\tv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\r\n\t\t\r\n\t\tbackCol2 += mix(.4, 1., v2) * vec3(1.8 * t3 * t3 * t3, 1.4 * t3 * t3, t3) * fade;\r\n\r\n\t\t\r\n\t\ts+=stepsize;\r\n\t\ts3 += stepsize;\t\t\r\n\t}\r\n\t\t       \r\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\t\r\n\r\n\tvec4 forCol2 = vec4(v*.01,1.);\t\r\n\t#ifdef cloud\r\n\tbackCol2 *= cloud;\r\n\t#endif\t\r\n\tbackCol2.b *= -3.8;\r\n\tbackCol2.r *= 0.05;\t\r\n\t\r\n\tbackCol2.b = 1.5*mix(backCol2.g, backCol2.b, 0.1);\r\n\tbackCol2.g = -0.;\r\n\tbackCol2.bg = mix(backCol2.gb, backCol2.bg, 0.39*(cos(1.00) + 1.0));\t\r\n\tgl_FragColor = forCol2 + vec4(backCol2, 1.0);\r\n}";
/*  5 */   public static String Minecraft = "precision highp float;\r\n\r\nuniform vec2 resolution;\r\nuniform float time;\r\nuniform vec2 mouse;\r\n\r\n#define iResolution resolution\r\n#define iTime time\r\n#define iMouse mouse\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\r\n\r\nvoid main(void) {\r\n    vec4 col;\r\n    mainImage(col, gl_FragCoord.xy);\r\n    gl_FragColor = col;\r\n}\r\n// Created by inigo quilez - iq/2014\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// { 2d cell id, distance to border, distnace to center )\r\n// Minecraft. Created by Reinder Nijhoff 2013\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4ds3WS\r\n//\r\n// port of javascript minecraft: http://jsfiddle.net/uzMPU/\r\n// original code by Markus Persson: https://twitter.com/notch/status/275331530040160256\r\n// combined with voxel-shader by inigo quilez (https://www.shadertoy.com/view/4dfGzs)\r\n// \r\n// All credits goes to inigo quilez!\r\n//\r\n\r\n#define SEALEVEL -25.\r\n#define MAXSTEPS 180 \r\n//#define HOUSE\r\n\r\nvec3 sundir = normalize( vec3(-0.5,0.6,0.7) );\r\n\r\nfloat hash( in float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat hash( in vec3 x ) {\r\n\tfloat n = dot( x, vec3(1.0,113.0,257.0) );\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nvec3 hash3( vec3 n ) {\r\n\treturn fract(sin(n)*vec3(653.5453123,4456.14123,165.340423));\r\n}\r\n//\t<https://www.shadertoy.com/view/4dS3Wd>\r\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\r\n//\r\n\r\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\r\n\r\nfloat noise(float x) {\r\n\tfloat i = floor(x);\r\n\tfloat f = fract(x);\r\n\tfloat u = f * f * (3.0 - 2.0 * f);\r\n\treturn mix(hash(i), hash(i + 1.0), u);\r\n}\r\n\r\nfloat noise(vec2 x) {\r\n\tvec2 i = floor(x);\r\n\tvec2 f = fract(x);\r\n\r\n\t// Four corners in 2D of a tile\r\n\tfloat a = hash(i);\r\n\tfloat b = hash(i + vec2(1.0, 0.0));\r\n\tfloat c = hash(i + vec2(0.0, 1.0));\r\n\tfloat d = hash(i + vec2(1.0, 1.0));\r\n\r\n\t// Simple 2D lerp using smoothstep envelope between the values.\r\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\r\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\r\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\r\n\r\n\t// Same code, with the clamps in smoothstep and common subexpressions\r\n\t// optimized away.\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\n\r\n// This one has non-ideal tiling properties that I'm still tuning\r\nfloat noise(vec3 x) {\r\n\tconst vec3 step = vec3(110, 241, 171);\r\n\r\n\tvec3 i = floor(x);\r\n\tvec3 f = fract(x);\r\n \r\n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \r\n\t// incremental change to the 1D based on the 3D -> 1D wrapping\r\n    float n = dot(i, step);\r\n\r\n\tvec3 u = f * f * (3.0 - 2.0 * f);\r\n\treturn mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\r\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\r\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\r\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\r\n}\r\nfloat sum(vec3 v) { return dot(v, vec3(1.0)); }\r\n\r\n// port of minecraft\r\n\r\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\r\n\t// 16x16 tex\r\n\tvec2 uv = floor( coord );\r\n\r\n    float n = uv.x + uv.y*347.0 + 4321.0 * float(i);\r\n\tfloat h = hash(n);\r\n\t\t\r\n    float br = 1. - h * (96./255.);\r\n\tcolor = vec3( 150./255., 108./255.,  74./255.); // 0x966C4A;\r\n\t\t\t\r\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\r\n\t\r\n\tif (i == 1) {\r\n\t\tif( uv.y < (xm1 + 18.)) {\r\n\t\t\tcolor = vec3( 106./255., 170./255.,  64./255.); // 0x6AAA40;\r\n\t\t} else if (uv.y < (xm1 + 19.)) {\r\n\t\t\tbr = br * (2. / 3.);\r\n\t\t}\r\n\t}\r\n\tif (i == 4) {\r\n\t\tcolor = vec3( 127./255., 127./255., 127./255.); // 0x7F7F7F;\r\n\t}\t\r\n\tif (i == 7) {\r\n\t\tcolor = vec3( 103./255., 82./255.,  49./255.); // 0x675231;\r\n\t\tif ( h < 0.5 ) {\r\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\r\n\t\t}\t\r\n\t}\t\r\n#ifdef HOUSE\r\n\tif (i == 5) {\r\n\t\tcolor = vec3( 181./255.,  58./255.,  21./255.); // 0xB53A15;\r\n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\r\n\t\t\tcolor = vec3( 188./255., 175./255., 165./255.); // 0xBCAFA5;\r\n\t\t}\r\n\t}\r\n#endif\r\n\tif (i == 9) {\r\n\t\tcolor = vec3(  64./255.,  64./255., 255./255.); // 0x4040ff;\r\n\t}\t\r\n\tif (i == 8) {\r\n\t\tcolor = vec3(  80./255., 217./255.,  55./255.); // 0x50D937;\r\n\t\tif ( h < 0.5) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tif (i == 10) {\r\n\t\tcolor = vec3(0.65,0.68,0.7)*1.35; \r\n\t\tbr = 1.;\r\n\t}\r\n\tcolor *= br;\r\n\t\r\n\treturn true;\r\n}\r\n\r\n//=====================================================================\r\n// Code by inigo quilez - iq/2013:\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n                    -0.80,  0.36, -0.48,\r\n                    -0.60, -0.48,  0.64 );\r\n\r\nfloat mapTerrain( vec2 p ) {\r\n\tp *= 0.02;\r\n\r\n\tfloat f;\r\n    f = 0.33*noise( p*4.01 );\r\n\treturn  max( 50.0*f-30., SEALEVEL);\r\n}\r\n\r\nvec3 gro = vec3(0.0);\r\n\r\nbool map(in vec3 c ) {\r\n\tvec3 p = c + 0.5;\r\n    \r\n\tfloat f = mapTerrain( p.xz );\r\n\r\n\tvec2 fc = floor( c.xz * 0.05 );\r\n\tvec3 h = hash3( vec3( fc*vec2(213.123,2134.125), mapTerrain(fc) ) );\t\r\n\tbool hit = false;\r\n\t\r\n\tif( h.z > 0.75 ) {\r\n\t\tvec2 tp = floor(fc*20.+mod(h.yx*154.43125, 10.)) + 5.5;\r\n\t\tfloat h = mapTerrain( tp );\r\n\t\tif( h > SEALEVEL ) {\t\t\r\n\t\t\tif( all( equal( tp, p.xz ) ) ) hit = c.y < h+4.; // treetrunk\r\n\t\t\tif( distance( p, vec3( tp.x, h+6., tp.y ) ) < 2.5 ) hit = true; // leaves\r\n\t\t} \r\n\t}\r\n\t\r\n\thit = c.y < f ? true:hit; // ground\r\n\t\r\n\tif( c.y > 8. && \r\n\t   sin( (c.y-8.)*(3.1415/32.)) * (10./(c.y-7.)) * noise( c*0.08+(0.7*iTime)*vec3(0.3, 0.07, 0.12) ) \r\n\t   > 0.6 ) hit = true; // clouds\r\n\r\n#ifdef HOUSE\r\n\tvec2 hc = abs(c.xz - vec2( 32., 130.)); // house\r\n\tif( all( lessThan( hc, vec2( 6., 10. ) ) ) && c.y < -hc.x-12. ) {\r\n\t\thit = true;\r\n\t\tif( all( lessThan( hc, vec2( 2., 10. ) ) ) && c.y < -18. && c.y > -23. ) {\r\n\t\t\thit = false;\r\n\t\t}\r\n\t\tif( all( lessThan( hc, vec2( 5., 9. ) ) ) && c.y < -18. && c.y > -23. ) {\r\n\t\t\thit = false;\r\n\t\t}\r\n\t}\r\n#endif\r\n\t\r\n\tif( distance( gro, c ) < 1.5 ) return false;\r\n\t\r\n\treturn hit;\r\n}\r\n\r\n\r\nint mapMaterial(in vec3 c ) {\r\n\tint mat = 0;\r\n\tvec3 p = c + 0.5;\r\n    \r\n\tfloat f = ceil( mapTerrain( p.xz ) ); \r\n\t\r\n\tif( p.y <= f ) mat = 1; // ground\r\n\telse if( p.y < f+3. ) mat = 7; // treetrunk\r\n\telse if( p.y < f+10. ) mat = 8; // leaves\r\n\telse mat = 10; // clouds\r\n\t\r\n#ifdef HOUSE\r\n\tvec2 hc = abs(c.xz - vec2( 32., 130.));\r\n\tif( c.y < 0. && all( lessThan( hc, vec2( 6., 10. ) ) ) ) {\r\n\t\tmat = 5;\r\n\t\tif( !map( c+vec3(0.,1.,0.) ) ) mat = 6;\r\n\t}\r\n#endif\r\n\t\r\n\treturn mat;\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir ) {\r\n\tvec3 pos = floor(ro);\r\n\tvec3 ri = 1.0/rd;\r\n\tvec3 rs = sign(rd);\r\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\r\n\t\r\n\tfloat res = 0.0;\r\n\tvec3 mm = vec3(0.0);\r\n\tbool hit = false;\r\n\t\r\n\tfor( int i=0; i<MAXSTEPS; i++ ) \r\n\t{\r\n\t\tif( hit ) break;\r\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n\t\tdis += mm * rs * ri;\r\n        pos += mm * rs;\r\n\t\tif( map(pos) ) { hit = true;}\r\n\t}\r\n\r\n\tvec3 nor = -mm*rs;\r\n\tvec3 vos = pos;\r\n\t\r\n    // intersect the cube\t\r\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\r\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\r\n\t\r\n\toDir = mm;\r\n\toVos = vos;\r\n\r\n\treturn hit?t:0.;\r\n\r\n}\r\n\r\nfloat castVRay( in vec3 ro, in vec3 rd, in float maxDist ) {\r\n\r\n\tvec3 pos = floor(ro);\r\n\tvec3 ri = 1.0/rd;\r\n\tvec3 rs = sign(rd);\r\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\r\n\t\r\n\tfloat res = 1.0;\r\n\t\r\n\tfor( int i=0; i<18; i++ ) \r\n\t{\r\n\t\tif( map(pos) ) {res=0.0; break; }\r\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n\t\tdis += mm * rs * ri;\r\n        pos += mm * rs;\r\n\t}\r\n\t\r\n\treturn res;\r\n\r\n}\r\n\r\nvec3 path( float t ) {\r\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\r\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\r\n\t\r\n\treturn vec3( p.x, mapTerrain(p)+2.+4.*(1.-cos(iTime*0.1)), p.y );\r\n}\r\n\r\n\r\n//=====================================================================\r\n// Ambient occlusion \r\n\r\nvec4 edges( in vec3 vos, in vec3 nor, in vec3 dir )\r\n{\r\n\tvec3 v1 = vos + nor + dir.yzx;\r\n\tvec3 v2 = vos + nor - dir.yzx;\r\n\tvec3 v3 = vos + nor + dir.zxy;\r\n\tvec3 v4 = vos + nor - dir.zxy;\r\n\r\n\tvec4 res = vec4(0.0);\r\n\tif( map(v1) ) res.x = 1.0;\r\n\tif( map(v2) ) res.y = 1.0;\r\n\tif( map(v3) ) res.z = 1.0;\r\n\tif( map(v4) ) res.w = 1.0;\r\n\r\n\treturn res;\r\n}\r\n\r\nvec4 corners( in vec3 vos, in vec3 nor, in vec3 dir )\r\n{\r\n\tvec3 v1 = vos + nor + dir.yzx + dir.zxy;\r\n\tvec3 v2 = vos + nor - dir.yzx + dir.zxy;\r\n\tvec3 v3 = vos + nor - dir.yzx - dir.zxy;\r\n\tvec3 v4 = vos + nor + dir.yzx - dir.zxy;\r\n\r\n\tvec4 res = vec4(0.0);\r\n\tif( map(v1) ) res.x = 1.0;\r\n\tif( map(v2) ) res.y = 1.0;\r\n\tif( map(v3) ) res.z = 1.0;\r\n\tif( map(v4) ) res.w = 1.0;\r\n\r\n\treturn res;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    // inputs\t\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\t\r\n    vec2 mo = iMouse.xy / iResolution.xy;\r\n  \r\n\t\r\n\tfloat time = 2.0*iTime + 50.0*mo.x;\r\n    // camera\r\n\t\r\n\tfloat cr = 0.2*cos(0.1*iTime);\t\r\n\tvec3 ro = path( time );\r\n\tvec3 ta = path( time+4. );\r\n\tta.y = ro.y;\r\n\tgro = ro;\r\n\t\r\n\t// build ray\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\r\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\r\n\r\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\r\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\r\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\r\n\tcol *= 0.95;\r\n\t\r\n\tvec3 vos, dir;\r\n\tfloat t = castRay( ro, rd, vos, dir );\r\n\t\r\n\tif( t>0.0 ) {\r\n\t\tvec3 nor = -dir*sign(rd);\r\n\t\t\r\n\t\tvec3 pos = ro + rd*t;\r\n\t\tint mMat = mapMaterial( vos );\t\t\t\r\n\t\tvec3 mpos = mod( pos * 16., 16. );\r\n\t\t\r\n\t\tif( mMat == 1 ) {\r\n\t\t\tif( map( vos + vec3(0., 1., 0. ) ) ) {\r\n\t\t\t\tmMat = hash(vos) > 0.5?2:4; \r\n\t\t\t\tif( map( vos + vec3(0., 2., 0. ) ) ) mMat = 4;\r\n\t\t\t}\r\n\t\t\tif ( vos.y < SEALEVEL ) mMat = 9;\t\r\n\t\t} \r\n\t\t\r\n\t\tvec3 mCol;\r\n\t\tgetMaterialColor( mMat, nor.y!=0.?mpos.xz:nor.x!=0.?-mpos.zy+vec2(32.,32.):-mpos.xy+vec2(32.,32.),mCol );\r\n\t\t\r\n\t\t// lighting\r\n\t\tfloat dif = clamp( dot( nor, sundir ), 0.0, 1.0 );\r\n\t\tfloat sha = 0.0; if( dif>0.01) sha=castVRay(pos+nor*0.01,sundir,32.0);\r\n\t\tfloat bac = clamp( dot( nor, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\r\n\t\tfloat sky = 0.5 + 0.5*nor.y;\r\n\t\tfloat amb = 1.0;//clamp(0.75 + pos.y/100.0,0.0,1.0);\r\n\t\t\t\r\n        // ambient occlusion\r\n\t\t\r\n        vec4 ed = edges( vos, nor, dir );\r\n        vec4 co = corners( vos, nor, dir );\r\n        vec3 uvw = pos - vos;\r\n        vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\r\n\t\t\r\n        float occ = 0.0; \r\n        // (for edges)\r\n        occ += (    uv.x) * ed.x;\r\n        occ += (1.0-uv.x) * ed.y;\r\n        occ += (    uv.y) * ed.z;\r\n        occ += (1.0-uv.y) * ed.w;\r\n        // (for corners)\r\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\r\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\r\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\r\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\r\n        occ = 1.0 - occ/8.0;\r\n        occ = occ*occ;\r\n        occ = occ*occ;\r\n\t\t\r\n\t\t\r\n\t\tvec3 lin = vec3(0.0);\r\n\t\tlin += 4.0*dif*vec3(1.)*(0.5+0.5*occ)*(0.25+0.75*sha);\r\n\t\tlin += 1.8*bac*vec3(1.0,0.5,1.0)*(0.5+0.5*occ);\r\n\t\tlin += 4.0*sky*vec3(0.6,0.71,0.75)*occ;\r\n\t\r\n\t\t\r\n\t\tif( mMat == 10 ) {\r\n\t\t\tcol = mix( col, mCol*lin*0.6, 0.3);\t\t\r\n\t\t} else {\r\n\t\t\t// atmospheric\r\n\t\t\tcol = mix( mCol*lin*0.2, col, 1.0-exp(-0.0000001*t*t*t) );\r\n\t\t}\t\t\t\r\n\t}\r\n\t\r\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\r\n\t\r\n    // gamma\t\r\n\tcol = pow( col, vec3(0.45) );\r\n\t\r\n\t// contrast\r\n    col = col* 0.25 + 0.75*col*col*(3.0-2.0*col);\r\n\t\t\r\n    col = clamp( col, 0.0, 1.0 );\r\n\r\n\t// vignetting\t\r\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\t\r\n\tfragColor = vec4( col, 1.0 );\r\n}";
/*  6 */   public static String Mario = "/*\r\n * Original shader from: https://www.shadertoy.com/view/XtlSD7\r\n */\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n// glslsandbox uniforms\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n// shadertoy emulation\r\nfloat iTime = 0.0;\r\n#define iResolution resolution\r\n\r\n// Protect glslsandbox uniform names\r\n#define time        stemu_time\r\n\r\n// --------[ Original ShaderToy begins here ]---------- //\r\n// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 4.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX + floor(sin(pixelY*0.2+time*0.8)+sin(pixelY*0.5+time*3.7)), pixelY + floor(sin(pixelX*0.3+time*1.3)+sin(pixelX*0.7+time*5.)), screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}\r\n// --------[ Original ShaderToy ends here ]---------- //\r\n\r\n#undef time\r\n\r\nvoid main(void)\r\n{\r\n  iTime = mod(time, 45.0);\r\n  mainImage(gl_FragColor, gl_FragCoord.xy);\r\n}";
/*  7 */   public static String Nordlicht = "//Auroras by nimitz 2017 (twitter: @stormoid)\r\n\r\n/*\r\n\t\r\n\tThere are two main hurdles I encountered rendering this effect. \r\n\tFirst, the nature of the texture that needs to be generated to get a believable effect\r\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\r\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\r\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\r\n\r\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\r\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\r\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\r\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\r\n\tthe rest of the effect. Which is always the case for auroras.\r\n\r\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\r\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\r\n\r\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\r\n\tdirection. But this was not required for this demo and would be trivial to fix.\r\n*/\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nuniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\nuniform sampler2D backbuffer;\r\n\r\n\r\n#define iGlobalTime time\r\n#define iTime time\r\n#define iMouse (mouse * resolution)\r\n#define iResolution resolution.xy\r\n\r\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\r\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\r\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\r\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\r\n\r\nfloat triNoise2d(in vec2 p, float spd)\r\n{\r\n    float z=1.8;\r\n    float z2=2.5;\r\n\tfloat rz = 0.;\r\n    p *= mm2(p.x*0.06);\r\n    vec2 bp = p;\r\n\tfor (float i=0.; i<5.; i++ )\r\n\t{\r\n        vec2 dg = tri2(bp*1.85)*.75;\r\n        dg *= mm2(time * 10.*spd);\r\n        p -= dg/z2;\r\n\r\n        bp *= 1.3;\r\n        z2 *= .45;\r\n        z *= .42;\r\n\t\tp *= 1.21 + (rz-1.0)*.02;\r\n        \r\n        rz += tri(p.x+tri(p.y))*z;\r\n        p*= -m2;\r\n\t}\r\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\r\n}\r\n\r\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\r\nvec4 aurora(vec3 ro, vec3 rd)\r\n{\r\n    vec4 col = vec4(0);\r\n    vec4 avgCol = vec4(0);\r\n    \r\n    for(float i=0.;i<50.;i++)\r\n    {\r\n        float of = 0.006*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\r\n        float pt = ((.8+pow(i,1.4)*.002)-ro.y)/(rd.y*2.+0.4);\r\n        pt -= of;\r\n    \tvec3 bpos = ro + pt*rd;\r\n        vec2 p = bpos.zx;\r\n\t    \r\n\t//This controls the speed!!!\r\n        float rzt = triNoise2d(p, 0.06);\r\n        vec4 col2 = vec4(0,0,0, rzt);\r\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2)+i*0.043)*0.5+0.5)*rzt;\r\n        avgCol =  mix(avgCol, col2, .5);\r\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\r\n        \r\n    }\r\n    \r\n    col *= (clamp(rd.y*15.+.4,0.,1.));\r\n    \r\n    \r\n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\r\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\r\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.);\r\n    \r\n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\r\n    return col*1.8;\r\n    //return pow(col,vec4(1.))*2.\r\n}\r\n\r\n\r\n//-------------------Background and Stars--------------------\r\n\r\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\r\nvec3 hash33(vec3 p)\r\n{\r\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\r\n    p += dot(p.zxy, p.yxz+19.27);\r\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\r\n}\r\n\r\nvec3 stars(in vec3 p)\r\n{\r\n    vec3 c = vec3(0.);\r\n    float res = iResolution.x*1.;\r\n    \r\n\tfor (float i=0.;i<4.;i++)\r\n    {\r\n        vec3 q = fract(p*(.15*res))-0.5;\r\n        vec3 id = floor(p*(.15*res));\r\n        vec2 rn = hash33(id).xy;\r\n        float c2 = 1.-smoothstep(0.,.6,length(q));\r\n        c2 *= step(rn.x,.0005+i*i*0.001);\r\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.1+0.9);\r\n        p *= 1.3;\r\n    }\r\n    return c*c*.8;\r\n}\r\n\r\nvec3 bg(in vec3 rd)\r\n{\r\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\r\n    sd = pow(sd, 5.);\r\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\r\n    return col*.63;\r\n}\r\n//-----------------------------------------------------------\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = q - 0.5;\r\n\tp.x*=iResolution.x/iResolution.y;\r\n    \r\n    vec3 ro = vec3(0,0,-6.7);\r\n    vec3 rd = normalize(vec3(p,1.3));\r\n    vec2 mo = 100.0 / iResolution.xy-.5;\r\n\t\r\n\tmo.x += time*0.05;\r\n\tmo.y += abs(sin(time/10.0))*0.3;\r\n\t\r\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\r\n\tmo.x *= iResolution.x/iResolution.y;\r\n    rd.yz *= mm2(mo.y);\r\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\r\n    \r\n    vec3 col = vec3(0.);\r\n    vec3 brd = rd;\r\n    float fade = smoothstep(0.,0.01,abs(brd.y))*0.1+0.9;\r\n    \r\n    col = bg(rd)*fade;\r\n    \r\n    if (rd.y > 0.){\r\n        vec4 aur = smoothstep(0.,1.5,aurora(ro,rd))*fade;\r\n        col += stars(rd);\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n    }\r\n    else //Reflections\r\n    {\r\n        rd.y = abs(rd.y);\r\n        col = bg(rd)*fade*0.6;\r\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\r\n        col += stars(rd)*0.1;\r\n        col = col*(1.-aur.a) + aur.rgb;\r\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\r\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\r\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\r\n    }\r\n    \r\n\tfragColor = vec4(col, 1.);\r\n}\r\n\r\nconst int num_x = 100;\r\nconst int num_y = 5;\r\nfloat w = resolution.x;\r\nfloat h = resolution.y;\r\n \r\n\r\nvoid main( void ) {\r\n\tvec4 colo = vec4(0.0);\r\n\tmainImage(colo, gl_FragCoord.xy);\r\n\tgl_FragColor = colo;\r\n\t\r\n\t\r\n\t/*\r\n\tvec4 color = vec4(0.0);\r\n\tfor (int i = 0; i < num_x; ++i) {\r\n\t\tfor (int j = 0; j < num_y; ++j) {\r\n\t\t\tcolor += draw_ball(i, j);\r\n\t\t}\r\n\t}\r\n\tvec2 texPos = vec2(gl_FragCoord.xy/resolution);\r\n\tvec4 shadow = texture2D(backbuffer, texPos)*0.7;\r\n\tgl_FragColor = vec4(vec3(colo*0.6+color+shadow), 1.0);\r\n\t*/\r\n}";
/*  8 */   public static String Button = "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n \r\n \r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n#define mouse vec2(sin(time)/48., cos(time)/48.)\r\n#define iterations 14\r\n#define formuparam2 0.79\r\n \r\n#define volsteps 5\r\n#define stepsize 0.390\r\n \r\n#define zoom 0.900\r\n#define tile   0.850\r\n#define speed2  0.0 \r\n#define brightness 0.003\r\n#define darkmatter 0.400\r\n#define distfading 0.560\r\n#define saturation 0.800\r\n\r\n\r\n#define transverseSpeed zoom*2.0\r\n#define cloud 0.11 \r\n\r\n \r\nfloat triangle(float x, float a) { \r\n\tfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;\r\n\treturn output2;\r\n}\r\n \r\nfloat field(in vec3 p) {\t\r\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = 0.;\r\n\tfloat prev = 0.;\r\n\tfloat tw = 0.;\t\r\n\r\n\tfor (int i = 0; i < 6; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(time*0.7 + 2.0), -1.1+0.3*cos(time*0.3));\r\n\t\tfloat w = exp(-float(i) / 7.);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0., 5. * accum / tw - .7);\r\n}\r\n\r\n\r\n\r\nvoid main() {   \r\n     \tvec2 uv2 = 2. * gl_FragCoord.xy / vec2(512) - 1.;\r\n\tvec2 uvs = uv2 * vec2(512)  / 512.;\r\n\t\r\n\tfloat time2 = time;               \r\n        float speed = speed2;\r\n        speed = .01 * cos(time2*0.02 + 3.1415926/4.0);          \r\n\t\t\r\n    \tfloat formuparam = formuparam2;\r\n\t\r\n    \t\t\r\n\tvec2 uv = uvs;\t\t       \r\n\t\r\n\tfloat a_xz = 0.9;\r\n\tfloat a_yz = -.6;\r\n\tfloat a_xy = 0.9 + time*0.08;\t\r\n\t\r\n\tmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\t\r\n\tmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\t\t\r\n\tmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\r\n\t\r\n\r\n\tfloat v2 =1.0;\t\r\n\tvec3 dir=vec3(uv*zoom,1.); \r\n\tvec3 from=vec3(0.0, 0.0,0.0);                               \r\n        from.x -= 5.0*(mouse.x-0.5);\r\n        from.y -= 5.0*(mouse.y-0.5);\r\n               \r\n               \r\n\tvec3 forward = vec3(0.,0.,1.);   \r\n\tfrom.x += transverseSpeed*(1.0)*cos(0.01*time) + 0.001*time;\r\n\tfrom.y += transverseSpeed*(1.0)*sin(0.01*time) +0.001*time;\r\n\tfrom.z += 0.003*time;\t\r\n\t\r\n\tdir.xy*=rot_xy;\r\n\tforward.xy *= rot_xy;\r\n\tdir.xz*=rot_xz;\r\n\tforward.xz *= rot_xz;\t\r\n\tdir.yz*= rot_yz;\r\n\tforward.yz *= rot_yz;\r\n\t\r\n\tfrom.xy*=-rot_xy;\r\n\tfrom.xz*=rot_xz;\r\n\tfrom.yz*= rot_yz;\r\n\t\r\n\tfloat zooom = (time2-3311.)*speed;\r\n\tfrom += forward* zooom;\r\n\tfloat sampleShift = mod( zooom, stepsize );\r\n\t \r\n\tfloat zoffset = -sampleShift;\r\n\tsampleShift /= stepsize;\r\n\t\r\n\t\r\n\tfloat s=0.24;\r\n\tfloat s3 = s + stepsize/2.0;\r\n\tvec3 v=vec3(0.);\r\n\tfloat t3 = 0.0;\t\r\n\t\r\n\tvec3 backCol2 = vec3(0.);\r\n\tfor (int r=0; r<volsteps; r++) {\r\n\t\tvec3 p2=from+(s+zoffset)*dir;\r\n\t\tvec3 p3=from+(s3+zoffset)*dir;\r\n\t\t\r\n\t\tp2 = abs(vec3(tile)-mod(p2,vec3(tile*2.)));\r\n\t\tp3 = abs(vec3(tile)-mod(p3,vec3(tile*2.)));\t\t\r\n\t\t#ifdef cloud\r\n\t\tt3 = field(p3);\r\n\t\t#endif\r\n\t\t\r\n\t\tfloat pa,a=pa=0.;\r\n\t\tfor (int i=0; i<iterations; i++) {\r\n\t\t\tp2=abs(p2)/dot(p2,p2)-formuparam;\r\n\t\t\t\r\n\t\t\tfloat D = abs(length(p2)-pa);\r\n\t\t\ta += i > 7 ? min( 12., D) : D;\r\n\t\t\tpa=length(p2);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ta*=a*a;\r\n\t\t\r\n\t\tfloat s1 = s+zoffset;\r\n\t\t\r\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\t\t\r\n\t\t\t\r\n\t\tv+=fade;\r\n\t       \t\r\n\r\n\t\t\r\n\t\tif( r == 0 )\r\n\t\t\tfade *= (1. - (sampleShift));\r\n\t\t\r\n\t\tif( r == volsteps-1 )\r\n\t\t\tfade *= sampleShift;\r\n\t\tv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade;\r\n\t\t\r\n\t\tbackCol2 += mix(.4, 1., v2) * vec3(1.8 * t3 * t3 * t3, 1.4 * t3 * t3, t3) * fade;\r\n\r\n\t\t\r\n\t\ts+=stepsize;\r\n\t\ts3 += stepsize;\t\t\r\n\t}\r\n\t\t       \r\n\tv=mix(vec3(length(v)),v,saturation);\t\r\n\r\n\tvec4 forCol2 = vec4(v*.01,1.);\t\r\n\t#ifdef cloud\r\n\tbackCol2 *= cloud;\r\n\t#endif\t\r\n\tbackCol2.b *= 1.8;\r\n\tbackCol2.r *= 0.05;\t\r\n\t\r\n\tbackCol2.b = 0.5*mix(backCol2.g, backCol2.b, 0.8);\r\n\tbackCol2.g = 0.0;\r\n\tbackCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(time*0.01) + 1.0));\t\r\n\tgl_FragColor = forCol2 + vec4(backCol2, 1.0);\r\n}\r\n";
/*  9 */   public static String Loading = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n// woah circle\r\n// thanks http://glslsandbox.com/e#41504.0\r\n\r\nuniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n\r\nvoid main()\r\n{\r\n    vec2 r = resolution,\r\n    o = gl_FragCoord.xy - r/2.;\r\n    o = vec2(length(o) / r.y - .3, atan(o.y,o.x));    \r\n    vec4 s = 0.08*cos(1.5*vec4(0,1,2,3) + time + o.y + sin(o.x) * cos(time)),\r\n    e = s.yzwx, \r\n    f = min(o.x-s,e-o.x);\r\n    gl_FragColor = dot(clamp(f*r.y,0.,1.), 50.*(s-e)) * (s-.1) - f;\r\n}";
/* 10 */   public static String LoadingScreenSnow = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n#define PI 3.14159265359\r\n#define T (time / .5)\r\n\r\nvec3 hsv2rgb(vec3 c)\r\n{\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 4.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nconst float aoinParam1 = 0.7;\r\n\r\nfloat snow(vec2 uv,float scale)\r\n{\r\n\tfloat w=smoothstep(9.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\r\n\tuv+=(time*aoinParam1)/scale;uv.y+=time*0./scale;uv.x+=sin(uv.y+time*.05)/scale;\r\n\tuv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\r\n\tp=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\r\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\r\n    \treturn k*w;\r\n}\r\n\r\nvoid main( void ) {\r\n\r\n\tvec2 position = (( gl_FragCoord.xy / resolution.xy ) - 0.5);\r\n\tposition.x *= resolution.x / resolution.y;\r\n\t\r\n\tvec3 color = vec3(0.);\r\n\t\r\n\tfor (float i = 0.; i < PI*2.0; i += PI/20.0) {\r\n\t\tvec2 p = position - vec2(cos(i), sin(i)) * 0.15;\r\n\t\tvec3 col = hsv2rgb(vec3((i + T)/(PI*2.0), 1., 1));\r\n\t\tcolor += col * (2./512.) / length(p);\r\n\t}                 \r\n\r\n\tvec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y); \r\n\tvec3 finalColor=vec3(0);\r\n\tfloat c=smoothstep(1.,0.3,clamp(uv.y*.3+.9,1.,.85));\r\n\tc+=snow(uv,30.)*.3;\r\n\tc+=snow(uv,20.)*.5;\r\n\tc+=snow(uv,15.)*.8;\r\n\tc+=snow(uv,10.);\r\n\tc+=snow(uv,8.);\r\n\tc+=snow(uv,6.);\r\n\tc+=snow(uv,5.);\r\n\tfinalColor=(vec3(c));\t\r\n\tgl_FragColor = (vec4( color, 1.0 ) + vec4(finalColor,1)) / vec4(2, 2, 2, 1);\r\n\r\n}";
/* 11 */   public static String LoadingScreennoSnow = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n#define PI 3.14159265359\r\n#define T (time / .5)\r\n\r\nvec3 hsv2rgb(vec3 c)\r\n{\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 4.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nconst float aoinParam1 = 0.7;\r\n\r\nfloat snow(vec2 uv,float scale)\r\n{\r\n\tfloat w=smoothstep(9.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\r\n\tuv+=(time*aoinParam1)/scale;uv.y+=time*0./scale;uv.x+=sin(uv.y+time*.05)/scale;\r\n\tuv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\r\n\tp=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\r\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\r\n    \treturn k*w;\r\n}\r\n\r\nvoid main( void ) {\r\n\r\n\tvec2 position = (( gl_FragCoord.xy / resolution.xy ) - 0.5);\r\n\tposition.x *= resolution.x / resolution.y;\r\n\t\r\n\tvec3 color = vec3(0.);\r\n\t\r\n\tfor (float i = 0.; i < PI*2.0; i += PI/20.0) {\r\n\t\tvec2 p = position - vec2(cos(i), sin(i)) * 0.15;\r\n\t\tvec3 col = hsv2rgb(vec3((i + T)/(PI*2.0), 1., 1));\r\n\t\tcolor += col * (2./512.) / length(p);\r\n\t}                 \r\n\r\n\tvec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y); \r\n\tvec3 finalColor=vec3(0);\r\n\tfloat c=smoothstep(1.,0.3,clamp(uv.y*.3+.9,1.,.85));\r\n\tc+=snow(uv,30.)*.3;\r\n\tc+=snow(uv,20.)*.5;\r\n\tc+=snow(uv,15.)*.8;\r\n\tc+=snow(uv,10.);\r\n\tc+=snow(uv,8.);\r\n\tc+=snow(uv,6.);\r\n\tc+=snow(uv,5.);\r\n\t//=(vec3(c));\t\r\n\tgl_FragColor = (vec4( color, 1.0 ) + vec4(finalColor,1)) / vec4(2, 2, 2, 1);\r\n\r\n}";
/* 12 */   public static String Smoke = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform float time;\r\n\r\nuniform vec2 resolution;\r\n\r\n#define speed 0.3\r\n#define freq 0.8\r\n#define amp 0.9\r\n#define phase 2.5\r\n\r\n\r\nvoid main( void ) {\r\n\r\n\tvec2 p =  vec2((gl_FragCoord.x / resolution.x) - 0.5, (gl_FragCoord.y / resolution.y) - 0.25);\r\n\t\r\n\tfloat sx = (amp)*1.2 * sin( 5.0 * (freq) * (p.x-phase) - 6.0 * (speed)*time);\r\n\t\r\n\tfloat dy = 43./ ( 90.0 * abs(4.9*p.y - sx - 1.1));\r\n\t\r\n\tdy += 3./ (60. * length(p - vec2(p.x, 0.)));\r\n\t\r\n\tgl_FragColor = vec4( (p.x + 0.025) * dy, 0.05 * dy, dy, 2.0 );\r\n\r\n}\r\n";
/* 13 */   public static String MainMenu = "/*\r\n * Original shader from: https://www.shadertoy.com/view/wd2GDG\r\n */\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n// glslsandbox uniforms\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n// shadertoy globals\r\nvec3  iResolution = vec3(0.0);\r\n\r\n// --------[ Original ShaderToy begins here ]---------- //\r\n/*\r\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\r\nYou can lower the MARCH_STEPS if too slow\r\n\r\nThe shader was made using Bonzomatic.\r\nYou can find the original shader here: http://lezanu.fr/LiveCode/RainyBridge.glsl\r\n*/\r\n\r\n#define MARCH_STEPS 100\r\n#define RAIN_STEPS 50\r\n#define SHAD_STEP 30\r\n\r\n//#define time iTime\r\n\r\nfloat PI = acos(-1.0);\r\n\r\nfloat sph(vec3 p, float r) {\r\n  return length(p)-r;\r\n}\r\n\r\nfloat cyl(vec2 p, float r) {\r\n  return length(p)-r;\r\n}\r\n\r\nfloat box(vec3 p, vec3 s) {\r\n  vec3 ap = abs(p)-s;\r\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\r\n}\r\n\r\nmat2 rot(float a) {\r\n  float ca=cos(a);\r\n  float sa=sin(a);\r\n  return mat2(ca,sa,-sa,ca);\r\n}\r\n\r\nvec3 tunnel(vec3 p) {\r\n  //return vec3(0.0);\r\n  vec3 off = vec3(0.0);\r\n  off.x += sin(p.z*0.2) + sin(p.z*0.137)*3.0;\r\n  off.y += sin(p.z*0.5)*0.2 + p.z*0.3;\r\n  return off;\r\n}\r\n\r\nfloat smin(float a, float b, float h) {\r\n  float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\r\n  return mix(a, b, k) - k*(1.0-k)*h;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n\r\n  float water = 10.0-p.y-p.z*0.3;\r\n\r\n  p += tunnel(p);\r\n\r\n  vec3 rp = p;\r\n  float sizerepeat = 2.0;\r\n  rp.z = (fract(rp.z/sizerepeat-0.5)-0.5)*sizerepeat;\r\n  \r\n  rp.yz *= rot(-rp.z*0.2);\r\n  float bridge = box(rp + vec3(0,-1,0), vec3(1.0,0.2,2.0));\r\n\r\n  \r\n  vec3 rp4 = rp + vec3(0,-0.8,0);\r\n  rp4.x += sin(p.z*8.0)*0.05;\r\n  rp4.y += cos(p.z*7.0)*0.05;\r\n  float size4 = 0.14;\r\n  rp4.xz = (fract(rp4.xz/size4-0.5)-0.5)*size4;\r\n  float bricks = box(rp4, vec3(0.05))-0.015;\r\n  bricks = max(bricks, bridge - 0.05);\r\n\r\n  bridge = smin(bridge, bricks, 0.09);\r\n\r\n\r\n  rp.x = abs(rp.x) - 1.0;\r\n  \r\n  float bar = box(rp + vec3(0,-0.5,0), vec3(0.05,0.05,2.0));\r\n  vec3 rp2 = rp;\r\n  float size2 = 0.2;\r\n  rp2.z = (fract(rp2.z/size2-0.5)-0.5)*size2;\r\n  bar = min(bar, box(rp2 + vec3(0,-0.8,0), vec3(0.03,0.3,0.03)));\r\n\r\n  bridge = min(bridge, bar);\r\n\r\n  vec3 rp3 = p + vec3(1,0,1.0);\r\n  float size3 = sizerepeat * 2.0;\r\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\r\n  float def = sin(rp3.y*17.0+2.0)*0.5+0.5;\r\n  def = sin(rp3.y*10.0 + def*3.0);\r\n  def = smoothstep(0.0,1.0,def);\r\n  def = smoothstep(0.0,1.0,def);\r\n  float lsize = 0.05 + (def)*0.02;\r\n  float lamp = max(cyl(rp3.xz + vec2(0,0), lsize), abs(rp3.y)-1.0);\r\n\r\n  vec3 lpos = rp3 + vec3(0,1,0);\r\n  float top = sph(lpos, 0.3);\r\n  top = max(top, -sph(lpos-vec3(0,0.3,0), 0.5));\r\n\r\n  lpos.y = max(abs(lpos.y)-0.1,0.0);\r\n  //lamp = min(lamp, sph(lpos, 0.12));\r\n  \r\n  //lamp = min(lamp, top);\r\n  lpos = abs(lpos)-0.1;\r\n  lpos.xz *= rot(PI*0.25);\r\n  //lamp = max(lamp, -box(lpos, vec3(0.05,0.2,0.05)));  \r\n  bridge = min(bridge, lamp);\r\n\r\n  bridge = min(bridge, water);\r\n\r\n  return bridge;\r\n\r\n}\r\n\r\n\r\nfloat lighting(vec3 p) {\r\n\r\n  p += tunnel(p);\r\n\r\n  float sizerepeat = 2.0;\r\n  vec3 rp3 = p + vec3(1,0,1.0);\r\n  float size3 = sizerepeat * 2.0;\r\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\r\n\r\n  vec3 lpos = rp3 + vec3(0,1,0);\r\n  float top = sph(lpos, 0.3);\r\n  return sph(lpos, 0.12);\r\n}\r\n\r\nvec3 norm(vec3 p) {\r\n  vec2 off=vec2(0.01,0);\r\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\r\n}\r\n\r\nvec3 getlightdir(vec3 p) {\r\n  vec2 off=vec2(0.01,0);\r\n  return normalize(lighting(p)-vec3(lighting(p-off.xyy), lighting(p-off.yxy), lighting(p-off.yyx)));\r\n}\r\n\r\nfloat rnd(float t) {\r\n\r\n  return fract(sin(t*745.523)*7894.552);\r\n\r\n}\r\n\r\nfloat rain(vec3 p) {\r\n\r\n  p.y -= time*4.0;\r\n  p.xy *= 60.0;\r\n  \r\n  p.y += rnd(floor(p.x))*80.0;\r\n  \r\n  return clamp(1.0-length(vec2(cos(p.x * PI), sin(p.y*0.1) - 1.7)), 0.0, 1.0);\r\n}\r\n\r\nfloat ripple(vec3 p) {\r\n\r\n  float t2 = time*5.0;\r\n\r\n  float size3 = 0.2;\r\n  vec3 rp3 = p + vec3(1,0,1.0);\r\n  \r\n  float id = dot(floor(rp3.xz/size3-0.5), vec2(7.52,5.48));\r\n  rp3.xz = (fract(rp3.xz/size3-0.5)-0.5)*size3;\r\n  \r\n\r\n  float r = clamp(1.0-length(rp3.xz)*20.0, 0.0, 1.0);\r\n  float looplen = 0.5;\r\n  float off = rnd(id * 75.5238);\r\n  float fl = 1.0-fract(time*looplen + off);\r\n  fl = pow(fl,10.0);\r\n  //float il = floor(time*looplen);\r\n  float r2 = cos(r*10.0 + t2) * fl;\r\n\r\n\r\n  return r2*r;\r\n\r\n}\r\n\r\nfloat ripples(vec3 p) {\r\n\r\n  float r = 0.0;\r\n  for(int i=0; i<5; ++i) {\r\n    vec3 cur = p + vec3(rnd(float(i)), 0, rnd(float(i)+75.523));\r\n    cur *= rnd(float(i)+12.71)*0.2+0.8;\r\n    cur *= 3.0;\r\n    r += ripple(cur);\r\n  }\r\n  return r;\r\n}\r\n\r\nvec3 ripplenorm(vec3 n, vec3 p) {\r\n\r\n  vec2 off = vec2(0.01,0.0);\r\n\r\n  vec3 rn = normalize(vec3(ripples(p+off.xyy)-ripples(p-off.xyy), 1.9, ripples(p+off.yyx)-ripples(p-off.yyx)));\r\n  n.xz += rn.xz * (abs(n.y));\r\n  //n.y *= rn.y;\r\n  return n;\r\n  \r\n}\r\n\r\nfloat rnd(vec2 uv) {\r\n  return fract(dot( sin(uv*vec2(784.553) + uv.yx*vec2(546.124)), vec2(7845.523) ));\r\n}\r\n\r\nfloat curve(float t, float r, float p) {\r\n  float g = t/r;\r\n  return mix(step(rnd(floor(g)), p), step(rnd(floor(g)+1.0), p), fract(g));\r\n}\r\n\r\nfloat shadow(vec3 s, vec3 r, float maxdist, float rn) {\r\n  float shad = 1.0;\r\n  const int steps = SHAD_STEP;\r\n  vec3 raystep = r*maxdist/float(steps);\r\n  vec3 p = s + raystep*rn;\r\n  for(int i=0; i<steps; ++i) {\r\n    float d = map(p);\r\n    if(d<0.01) {\r\n      shad = 0.0;\r\n      break;\r\n    }\r\n    p += raystep;\r\n  }\r\n  return shad;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\r\n  uv -= 0.5;\r\n  uv /= vec2(iResolution.y / iResolution.x, 1);\r\n\r\n  vec3 s = vec3(1,sin(time*0.3)*0.2,-3);\r\n  vec3 t = vec3(0,0,0);\r\n/*\r\n  float t1 = fract(time*0.1);\r\n  s.z += t1;\r\n  t.z += t1;\r\n\r\n  s -= tunnel(s);\r\n  t -= tunnel(t);\r\n  \r\n  vec3 cz = normalize(t-s);\r\n  vec3 cx = normalize(cross(cz, vec3(0,1,0)));\r\n  vec3 cy = normalize(cross(cz, cx));\r\n  vec3 r = normalize(uv.x*cx + uv.y*cy + cz * 0.7);\r\n*/\r\n\r\n  vec3 r = normalize(vec3(-uv,0.7));\r\n  \r\n\r\n  \r\n  vec3 p = s;\r\n  float dd=0.0;\r\n  for(int i=0; i<MARCH_STEPS; ++i) {\r\n    float d = map(p);\r\n    if(d<0.001) {\r\n      break;\r\n    }\r\n    if(dd>100.0) {\r\n      dd=100.0;\r\n      break;\r\n    }\r\n    p+=r*d;\r\n    dd+=d;\r\n  }\r\n\r\n  vec3 col = vec3(0.0);\r\n  vec3 n = norm(p);\r\n\r\n  n = ripplenorm(n, p);\r\n\r\n\r\n  float lightning = curve(time, 0.2, 0.1);\r\n  //float idlightning = floor(time/0.4-0.5);\r\n  float idlightning = 0.0;\r\n\r\n  float fog = 1.0-pow(clamp(dd/50.0,0.0,1.0),0.2);\r\n  vec3 lmoon = normalize(vec3(-8,-3,-3.0 + sin(idlightning)*3.0));\r\n\r\n  float shad = shadow(p + n * 0.02, lmoon, 3.0, rnd(uv));\r\n\r\n  col += lightning * 5.0 * max(0.0, dot(n, lmoon)) * fog * shad;\r\n\r\n  vec3 l = -getlightdir(p);\r\n  float ldist = lighting(p);\r\n\r\n  vec3 h = normalize(l-r);\r\n\r\n  //col += fract(length(light-p)*10.5);\r\n  //vec3 l = normalize(light-p);\r\n  //float ldist = dot(light-p, light-p);\r\n  col += max(0.0, dot(n, l)) * fog * 10.0 * (0.4 + 2.0*pow(max(0.0, dot(n,h)),30.0) )/(ldist*ldist*ldist*ldist);\r\n\r\n  float at = 0.0;\r\n  vec3 raining = vec3(0.0);\r\n  const int steps = RAIN_STEPS;\r\n  float stepsize = 30.0 / float(steps);\r\n  vec3 raystep = r * stepsize / r.z;\r\n  //vec3 raypos = s + raystep;\r\n  for(int i=0; i<steps; ++i) {\r\n    vec3 raypos = s + raystep * (float(i)+1.0);\r\n    float tot = length(raypos-s);\r\n\r\n    if(tot>dd) break;\r\n    float fog2 = 1.0-pow(clamp(tot/40.0,0.0,1.0),0.5);\r\n\r\n    \r\n    vec3 ldir = getlightdir(raypos);\r\n    float l2dist = lighting(raypos);\r\n    float curlight = 1.0/pow(l2dist,2.0);\r\n\r\n    vec3 rainpos = raypos;\r\n    rainpos.xy *= rot(sin(float(i)*0.2)*0.01 + sin(time)*0.009);\r\n    rainpos.xy += rnd(float(i))*vec2(7.52,13.84);\r\n    raining += rain(rainpos) * fog2 * (lightning*0.5 + pow(curlight,2.0));\r\n\r\n    //vec3 ldir = light-raypos;\r\n    at += 0.04*curlight * fog2;\r\n    //raypos += raystep;    \r\n  }\r\n  col += at;\r\n  col += raining;\r\n/*\r\n  col = vec3(rain(vec3(-uv,5)));\r\n  col += rain(vec3(-uv*2.3,5)) * 0.5;\r\n  col += rain(vec3(-uv*4.7,5)) * 0.25;\r\n*/\r\n  //col = ripplenorm(n, vec3(-uv.x,0.0,-uv.y)); \r\n\r\n  col = pow(col, vec3(0.4545));\r\n  col *= vec3(0.1, 0.2, 0.35);\r\n  fragColor = vec4(col, 1);\r\n}\r\n\r\n// --------[ Original ShaderToy ends here ]---------- //\r\n\r\nvoid main(void)\r\n{\r\n    iResolution = vec3(resolution, 0.0);\r\n    mainImage(gl_FragColor, gl_FragCoord.xy);\r\n}";
/* 14 */   public static String Options = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n#extension GL_OES_standard_derivatives : enable\r\n\r\nuniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n\r\nfloat hex(vec2 p) {\r\n\tp = abs(p);\r\n\treturn max(dot(p, vec2(.5, .86)), p.x);\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec2 p = (2. * gl_FragCoord.xy - resolution) / resolution.y*((sin(time) * 3.0)+3.0);\r\n\tvec3 col = vec3(0.);\r\n\tfor(float i = 0.0; i < 20.0; i++)\r\n\t{\r\n\t\tcol += .01 / abs(hex(p * (i * 0.2)) - 1.0);\r\n\t}\r\n\t\r\n\tgl_FragColor = vec4(col, 1.);\r\n\r\n\r\n}";
/* 15 */   public static String AddServer = "/*\r\n * Original shader from: https://www.shadertoy.com/view/wljSz1\r\n */\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n// glslsandbox uniforms\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n// shadertoy emulation\r\n#define iTime time\r\n#define iResolution resolution\r\n\r\n// Emulate a black texture\r\n#define texture(s, uv) vec4(0.0)\r\n#define texelFetch(s, uv, lod) vec4(0.0)\r\n\r\n// --------[ Original ShaderToy begins here ]---------- //\r\n//#define SPLOTCHES\r\n#define BUMPY\r\nfloat T = 0.;\r\nfloat hash(float x){\r\n    return fract(sin(x*54265.135165416));\r\n}\r\n\r\n// by TinyTexel, mentioned at https://www.iquilezles.org/www/articles/smin/smin.htm\r\nfloat smin(float a, float b, float k){\r\n    float h = max(k-abs(a-b), 0.0)/k;\r\n    return min(a, b) - h*h*h*k*(3.0/6.0);\r\n}\r\n\r\n// store the matrix globally so the 2D \"normal map\" sticks better\r\nmat2 R;\r\nfloat map(vec3 p){\r\n    // rotate\r\n    float r = 3.14159*sin(p.z*0.15)+T*0.1;\r\n    R = mat2(cos(r), sin(r), -sin(r), cos(r));\r\n    p.xy *= R;\r\n    vec3 op = p;\r\n    \r\n    // per-cell random values\r\n    float h = hash(floor(p.x+p.y+p.z));\r\n    float h2 = 3.141*hash(floor(-p.x-p.y-p.z));\r\n    \r\n    // bumpy\r\n    #ifdef BUMPY\r\n    float f = pow(texture(iChannel2, p*0.1).b,4.0);\r\n   \tvec3 dd = vec3(sin(p.z*71.), cos(p.x*73.), -cos(p.y*77.))\r\n               -0.6*vec3(cos(p.y*141.), sin(p.z*143.), -sin(p.x*147.));\r\n    p = mix(p, p-dd*0.005, f);\r\n    #endif\r\n    \r\n    // repeat lattice\r\n    const float a = 1.0;\r\n    p = mod(p, a)-a*0.5;\r\n    \r\n    // primitives\r\n    // center sphere\r\n    float v = length(p)-(0.02+(0.18*h*(0.6+0.4*sin(3.0*T+h2)) ));\r\n    // four connecting cylinders\r\n    v = smin(v, length(p.xy+0.01*sin(-3.2*T+13.0*op.z))-0.03, 0.2);\r\n    v = smin(v, length(p.xz+0.01*cos(-4.1*T+11.0*(op.y-op.z)))-0.03, 0.2);\r\n    v = smin(v, length(p.yz+0.01*sin(-5.0*T-8.0*(op.x-op.z)))-0.03, 0.2);\r\n    \r\n    return v;\r\n}\r\n\r\nvec3 normal(vec3 p){\r\n\tfloat o = map(p);\r\n    const float e = 0.001;\r\n    return normalize( vec3(map(p+vec3(e,0,0))-o,\r\n                           map(p+vec3(0,e,0))-o,\r\n                           map(p+vec3(0,0,e))-o));\r\n}\r\n\r\nvec3 march(vec3 o, vec3 dir){\r\n    vec3 p = o;\r\n    float e = 0.0;\r\n    for(int i = 0; i < 100; ++i){\r\n        float d = 0.5*map(p);\r\n        e += d;\r\n        if(d < 0.03 || e > 6.0)\r\n            break;\r\n        p += d*dir;\r\n    }\r\n    \r\n    return p;\r\n}\r\n\r\nvec4 subsurface(vec3 o, vec3 dir){\r\n    vec3 p = o;\r\n    float e = 0.0;\r\n    for(int i = 0; i < 7; ++i){\r\n        float d = map(p);\r\n        e += -d;\r\n        if(d > -0.001)\r\n            break;\r\n        p -= d*dir;\r\n    }\r\n    \r\n    return vec4(p, e);\r\n}\r\n\r\nfloat G(float dotNV, float k){\r\n\treturn 1.0/(dotNV*(1.0-k)+k);\r\n}\r\n\r\n// from http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\r\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\r\n\tfloat alpha = roughness*roughness;\r\n\r\n\tvec3 H = normalize(V+L);\r\n\r\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\r\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\r\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\r\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\r\n\r\n\tfloat F, D, vis;\r\n\r\n\tfloat alphaSqr = alpha*alpha;\r\n\tfloat pi = 3.14159;\r\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 7.0;\r\n\tD = alphaSqr/(pi * denom * denom);\r\n\r\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\r\n\tF = F0 + (1.0 - F0)*(dotLH5);\r\n\r\n\tfloat k = alpha * 0.5;\r\n\r\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n    \r\n    const float tm = 2.0;\r\n    T = iTime*tm;\r\n    float ot = T;\r\n    \r\n    // quadratic, increase this if your gpu is gpu enough\r\n    const int samples = 2;\r\n    \r\n    vec3 c = vec3(0);\r\n    for(int y = 0; y < samples; ++y)\r\n    for(int x = 0; x < samples; ++x){\r\n        // anti-aliasing\r\n        vec2 p = -1.0 + 2.0 * (uv + (-0.5+(vec2(x, y)/float(samples)))/iResolution.xy);\r\n        p.x *= iResolution.x/iResolution.y;\r\n        \r\n        // motion blur\r\n        float r = texelFetch(iChannel0, ivec2(mod(fragCoord*float(samples)+vec2(x,y),1024.)),0).r;\r\n        T = ot+(tm*r)/36.0;\r\n        \r\n        // camera setup\r\n        vec3 cam = vec3(0.1*sin(T*0.51),0.1*cos(T*0.59),T);\r\n        vec3 l = vec3(0.6*cos(T*0.83),0.6*sin(T*0.79),cam.z+3.0+0.5*sin(0.7*T));\r\n    \tvec3 dir = normalize(vec3(p, 2.0)+0.1*vec3(sin(T*0.63),cos(T*0.71),0));\r\n        \r\n        // solve intersection and normal\r\n    \tvec3 pos = march(cam, dir);\r\n        vec3 mp = pos;\r\n        mp.xy *= R;\r\n        vec3 np = pos+vec3(0,0,-0.08*texture(iChannel1, mp.xy*4.0).r);\r\n        vec3 n = normalize(mix(normal(np), pow(texture(iChannel2, pos*2.0).xyz, vec3(2)), 0.08));\r\n        \r\n        // shade\r\n        vec3 ld = normalize(l-pos);\r\n        vec3 alb = mix((vec3(0.3,0.5,0.9)),\r\n                       (vec3(0.75,0.9,0.4)),\r\n                       texture(iChannel2, 0.04*mp).r)*1.25;\r\n        #ifdef SPLOTCHES\r\n        float mat = smoothstep(0.1,0.8,pow(texture(iChannel2, 0.14*mp).b, 3.0));\r\n        alb = mix(alb, vec3(0.9,0.78,0.42), mat);\r\n        #endif\r\n        float dif = 0.5+0.5*dot(n, ld);\r\n        \r\n        #ifdef SPLOTCHES\r\n        float spe = ggx(n, -dir, ld, mix(0.3,0.5,mat), mix(0.7,1.0,mat));\r\n        #else\r\n        float spe = ggx(n, -dir, ld, 0.3, 0.7);\r\n        #endif\r\n        float att = 1.0+pow(distance(l, pos), 2.0);\r\n        dif /= att;\r\n        spe /= att;\r\n        \r\n        // subsurface scattering\r\n        vec3 h = normalize(mix(-normal(pos), dir, 0.5));\r\n        // sv.zyz contains outgoing position, w contains accumulate distance (path \"tightness)\r\n        vec4 sv = subsurface(pos+h*0.02, dir);\r\n        // subsurface magic term\r\n        float sss = max(0.0, 1.0-3.0*sv.w);\r\n        // light visibility across the volume\r\n        float ssha = max(0.0, dot(normal(sv.xyz), normalize(l-sv.xyz)));\r\n        sss /= att;\r\n        ssha /= att;\r\n        \r\n        // mix reflecting and refracting contributions\r\n        dif = mix(dif, mix(sss, ssha, 0.2), 0.5);\r\n        \r\n        c += alb*dif+0.025*spe;\r\n    }\r\n    \r\n\tfragColor.rgb = c/float(samples*samples);\r\n    \r\n    // \"color grade\" and gamma\r\n    fragColor.rgb = mix(vec3(dot(fragColor.rgb, vec3(.2125,.7154,.0721))), fragColor.rgb, 9.0);\r\n    fragColor.rgb = smoothstep(0.0, 1.25, fragColor.rgb);\r\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\r\n}\r\n// --------[ Original ShaderToy ends here ]---------- //\r\n\r\nvoid main(void)\r\n{\r\n    mainImage(gl_FragColor, gl_FragCoord.xy);\r\n    gl_FragColor.a = 1.0;\r\n}";
/* 16 */   public static String CreateWorld = "\r\n// https://www.shadertoy.com/view/tljSWV\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\nmat2 rotate(float a)\r\n{\r\n\tfloat c = cos(a);\r\n\tfloat s = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\nvoid main()\r\n{\r\n\tvec2 uv = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\r\n\tvec2 f = vec2(0.3);\r\n\tvec3 c = vec3(1.0,1.0,1.0);\r\n\tfloat light = 0.1;\r\n\t\r\n\tfor (float x = 1.1; x < 12.0; x += 1.0)\r\n\t{\r\n\t\tuv *= rotate(x*200.0+sin(time*0.1));\r\n\t\t\r\n\t\tf = vec2(cos(cos(time*03.6+x + uv.x * x) - uv.y * dot(vec2(x + uv.y), vec2(sin(x), cos(x)))));\r\n\t\tlight += (0.04 / distance(uv, f)) - (0.04 * distance(vec2((cos(time*0.3 + uv.y))), vec2(uv)));\r\n\t\t\r\n\t\tc.y += sin(x+time+abs(uv.y))*0.3;\r\n\t\tif (c.y<0.8)\r\n\t\t\tc.y = 0.8;\r\n\t\tlight-=x*0.001 + c.y*0.005;\r\n\t\t\r\n\t}\r\n\t\r\n\tc *= light;\r\n\tc.x += (sin(time*5.4)*0.2);\r\n\t\r\n\tgl_FragColor = vec4(c, 1.0);\r\n}";
/* 17 */   public static String Mori0 = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n#extension GL_OES_standard_derivatives : enable\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n#define COL_RED 1.\r\n#define COL_GRN .0\r\n#define COL_BLU .0\r\n// 1\r\nfloat rand(float n)\r\n{\r\n   float fl = floor(n);\r\n   float fc = fract(n);\r\n   return mix(fract(sin(fl)), fract(sin(fl + 1.0)), fc);\r\n}\r\n\r\n// 2\r\nvec2 rand2(in vec2 p)\r\n{\r\n   return fract(\r\n       vec2(\r\n           sin(p.x * 1.32 + p.y * 78.544),\r\n           cos(p.x * 91.32 + p.y * 13.077)\r\n       )\r\n   );\r\n}\r\n\r\n// iqa\r\n// https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\r\nfloat voronoi(in vec2 v, in float e)\r\n{\r\n   vec2 p = floor(v);\r\n   vec2 f = fract(v);\r\n   \r\n   vec2 res = vec2(1.0);\r\n   \r\n   for(int j = -1; j <= 1; ++j)\r\n       for(int i = -1; i <= 1; ++i)\r\n       {\r\n           vec2 b = vec2(i, j);\r\n           vec2 r = b - f + rand2(p + b);\r\n           \r\n           // a\r\n           float d = max(abs(r.x), abs(r.y));\r\n           \r\n           if(d < res.x)\r\n           {\r\n               res.y = res.x;\r\n               res.x = d;\r\n           }\r\n           \r\n           else if(d < res.y)\r\n           {\r\n               res.y = d;\r\n           }\r\n       }\r\n   \r\n   vec2 c = sqrt(res);\r\n   float dist = c.y - c.x;\r\n   //return dist+1.5;\r\n   // a\r\n   return 1.0 - smoothstep(0.0, e, dist);\r\n}\r\n\r\n// a\r\nmat2 rotate(in float a)\r\n{\r\n   return mat2(cos(a), -sin(a), sin(a), cos(a));\r\n}\r\n\r\nuniform vec2 mouse;\r\nvoid main(void)\r\n{\r\n   // a\r\n   vec2 uv =  gl_FragCoord.xy / resolution * 4.0 - 2.0;\r\n   \r\n   \r\n   uv.y *= resolution.y / resolution.x;\r\n   uv *= rotate(0.);\r\n   \r\n   // \r\n   float value = 0.0;     \r\n   float light = 0.0;\r\n   \r\n   float f = 1.;    // UV\r\n   float a = 0.7;    // value\r\n   \r\n   \r\n   for(int i = 0; i < 3; ++i)\r\n   {\r\n       // \r\n       float v1 = voronoi(uv * f + 1.0 + time * 0.2 , 0.1);\r\n       v1 = pow(v1, 2.0);\r\n       value += a * rand(v1 * 5.5 + 0.1);\r\n       \r\n       // \r\n       //float v2 = voronoi(uv * f * 1.5 + 5.0 + time, 0.2) * 0.6;\r\n       //v2 = pow(v2, 9.0);\r\n       //light += pow(v1 * (0.5 * v2), 1.5);\r\n       \r\n       // \r\n       f *= 2.0;\r\n       a *= 0.6;\r\n   }\r\n   \r\n   // \r\n   vec3 color;\r\n   color += vec3(COL_RED, COL_GRN, COL_BLU) * value;\r\n   //color += vec3(0.4, 0.7, 1.0) * light;\r\n   \r\n   // \r\n   gl_FragColor = vec4(color, 1.0);\r\n}";
/* 18 */   public static String City = "uniform vec2      resolution;           // viewport resolution (in pixels)\r\nuniform float     time;\r\n\r\n//#define FAST_DESCENT\r\n\r\n#ifdef FAST_DESCENT\r\nconst vec3 cameraDir = normalize(vec3(-2.0, -1.0, -4.0));\r\nconst float cameraDist = 5.0;\r\nconst float speed = 3.0;\r\nconst float zoom = 2.5;\r\n\r\nconst vec3 windowColorA = vec3(0.0, 0.0, 1.5);\r\nconst vec3 windowColorB = vec3(0.5, 1.5, 2.0);\r\n\r\nconst float fogOffset = 2.5;\r\nconst float fogDensity = 0.6;\r\nconst vec3 fogColor = vec3(0.25, 0.0, 0.3);\r\n\r\nconst float lightHeight = 0.5;\r\nconst float lightSpeed = 0.2;\r\nconst vec3 lightColorA = vec3(0.7, 0.3, 0.1);\r\nconst vec3 lightColorB = vec3(1.0, 0.6, 0.3);\r\n\r\nconst vec3 signColorA = vec3(0.0, 0.0, 1.5);\r\nconst vec3 signColorB = vec3(3.0, 3.0, 3.0);\r\n#else\r\nconst vec3 cameraDir = normalize(vec3(-2.0, -1.0, -2.0));\r\nconst float cameraDist = 9.0;\r\nconst float speed = 1.0;\r\nconst float zoom = 3.5;\r\n\r\nconst vec3 windowColorA = vec3(0.0, 0.0, 1.5);\r\nconst vec3 windowColorB = vec3(0.5, 1.5, 2.0);\r\n\r\nconst float fogOffset = 7.0;\r\nconst float fogDensity = 0.7;\r\nconst vec3 fogColor = vec3(0.25, 0.0, 0.3);\r\n\r\nconst float lightHeight = 0.0;\r\nconst float lightSpeed = 0.15;\r\nconst vec3 lightColorA = vec3(0.7, 0.3, 0.1);\r\nconst vec3 lightColorB = vec3(1.0, 0.6, 0.3);\r\n\r\nconst vec3 signColorA = vec3(0.0, 0.0, 1.5);\r\nconst vec3 signColorB = vec3(3.0, 3.0, 3.0);\r\n#endif\r\n\r\nconst float tau = 6.283185;\r\n\r\n\r\nfloat hash1(float p) {\r\n    vec3 p3 = fract(p * vec3(5.3983, 5.4427, 6.9371));\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nfloat hash1(vec2 p2) {\r\n    p2 = fract(p2 * vec2(5.3983, 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337);\r\n}\r\n\r\nfloat hash1(vec2 p2, float p) {\r\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec2 hash2(vec2 p2, float p) {\r\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n}\r\n\r\nvec3 hash3(vec2 p2) {\r\n    vec3 p3 = fract(vec3(p2.xyx) * vec3(5.3983, 5.4427, 6.9371));\r\n    p3 += dot(p3, p3.yxz + 19.19);\r\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\r\n}\r\n\r\nvec4 hash4(vec2 p2) {\r\n    vec4 p4 = fract(p2.xyxy * vec4(5.3983, 5.4427, 6.9371, 7.1283));\r\n    p4 += dot(p4, p4.yxwz + 19.19);\r\n    return fract((p4.xxxy + p4.yyzz + p4.zwww) * p4.wzyx);\r\n}\r\n\r\nfloat noise(vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n    vec2 u = f * f * (3.0 - 2.0 * f);\r\n    return mix(mix(hash1(i + vec2(0.0, 0.0)),\r\n                   hash1(i + vec2(1.0, 0.0)), u.x),\r\n               mix(hash1(i + vec2(0.0, 1.0)),\r\n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nvec4 castRay(vec3 eye, vec3 ray, vec2 center) {\r\n    vec2 block = floor(eye.xy);\r\n    vec3 ri = 1.0 / ray;\r\n    vec3 rs = sign(ray);\r\n    vec3 side = 0.5 + 0.5 * rs;\r\n    vec2 ris = ri.xy * rs.xy;\r\n    vec2 dis = (block - eye.xy + 0.5 + rs.xy * 0.5) * ri.xy;\r\n\r\n    for (int i = 0; i < 16; ++i) {\r\n        float d = dot(block - center, cameraDir.xy);\r\n        float height = 3.0 * hash1(block) - 1.0 + 1.5 * d - 0.1 * d * d;\r\n\r\n        vec2 lo0 = vec2(block);\r\n        vec2 loX = vec2(0.45, 0.45);\r\n        vec2 hi0 = vec2(block + 0.55);\r\n        vec2 hiX = vec2(0.45, 0.45);\r\n\r\n        float dist = 500.0;\r\n        float face = 0.0;\r\n\r\n        {\r\n            vec4 signHash = hash4(block);\r\n            vec2 center = vec2(0.2, -0.4) + vec2(0.6, -0.8) * signHash.xy;\r\n            float width = 0.06 + 0.1 * signHash.w;\r\n\r\n            vec3 lo = vec3(center.x - width, 0.55, -100.0);\r\n            vec3 hi = vec3(center.x + width, 0.99, center.y + width + height);\r\n\r\n            float s = step(0.5, signHash.z);\r\n            lo = vec3(block, 0.0) + mix(lo, lo.yxz, s);\r\n            hi = vec3(block, 0.0) + mix(hi, hi.yxz, s);\r\n\r\n            vec3 wall = mix(hi, lo, side);\r\n            vec3 t = (wall - eye) * ri;\r\n\r\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);\r\n            float maxT = dot(dim, t);\r\n            float maxFace = dim.x - dim.y;\r\n\r\n            vec3 p = eye + maxT * ray;\r\n            dim += step(lo, p) * step(p, hi);\r\n\r\n            if (dim.x * dim.y * dim.z > 0.5) {\r\n                dist = maxT;\r\n                face = maxFace;\r\n            }\r\n        }\r\n\r\n        for (int j = 0; j < 5; ++j) {\r\n            float top = height - 0.4 * float(j);\r\n            vec3 lo = vec3(lo0 + loX * hash2(block, float(j)), -100.0);\r\n            vec3 hi = vec3(hi0 + hiX * hash2(block, float(j) + 0.5), top);\r\n\r\n            vec3 wall = mix(hi, lo, side);\r\n            vec3 t = (wall - eye) * ri;\r\n\r\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);\r\n            float maxT = dot(dim, t);\r\n            float maxFace = dim.x - dim.y;\r\n\r\n            vec3 p = eye + maxT * ray;\r\n            dim += step(lo, p) * step(p, hi);\r\n\r\n            if (dim.x * dim.y * dim.z > 0.5 && maxT < dist) {\r\n                dist = maxT;\r\n                face = maxFace;\r\n            }\r\n        }\r\n\r\n        if (dist < 400.0) {\r\n            return vec4(dist, height, face, 1.0);\r\n        }\r\n\r\n        float t = eye.z * ri.z;\r\n        vec3 p = eye - t * ray;\r\n        vec2 g = p.xy - block;\r\n\r\n        vec2 dim = step(dis.xy, dis.yx);\r\n        dis += dim * ris;\r\n        block += dim * rs.xy;\r\n    }\r\n\r\n    return vec4(100.0, 0.0, 0.0, 1.0);\r\n}\r\n\r\nvec3 window(float z, vec2 id) {\r\n    float windowSize = 0.03 + 0.1 * hash1(id + 0.1);\r\n    float windowProb = 0.4 + 0.6 * hash1(id + 0.2);\r\n    float depth = z / windowSize;\r\n    float level = floor(depth);\r\n    vec3 colorA = mix(windowColorA, windowColorB, hash3(id));\r\n    vec3 colorB = mix(windowColorA, windowColorB, hash3(id + 0.1));\r\n    vec3 color = mix(colorA, colorB, hash1(id, level));\r\n    color *= smoothstep(windowProb - 0.2, windowProb + 0.2, hash1(id, level + 0.1));\r\n    return color * (0.5 - 0.5 * cos(tau * depth));\r\n}\r\n\r\nvec3 addLight(vec3 eye, vec3 ray, float res, float time, float height) {\r\n    vec2 q = eye.xy + ((height - eye.z) / ray.z) * ray.xy;\r\n\r\n    float row = floor(q.x + 0.5);\r\n    time += hash1(row);\r\n    float col = floor(0.125 * q.y - time);\r\n\r\n    float pos = 0.4 + 0.4 * cos(time + tau * hash1(vec2(row, col)));\r\n    vec3 lightPos = vec3(row, 8.0 * (col + time + pos), height);\r\n    vec3 lightDir = vec3(0.0, 1.0, 0.0);\r\n\r\n    // http://geomalgorithms.com/a07-_distance.html\r\n    vec3 w = eye - lightPos;\r\n    float a = dot(ray, ray);\r\n    float b = dot(ray, lightDir);\r\n    float c = dot(lightDir, lightDir);\r\n    float d = dot(ray, w);\r\n    float e = dot(lightDir, w);\r\n    float D = a * c - b * b;\r\n    float s = (b*e - c*d) / D;\r\n    float t = (a*e - b*d) / D;\r\n\r\n    t = max(t, 0.0);\r\n    float dist = distance(eye + s * ray, lightPos + t * lightDir);\r\n\r\n    float mask = smoothstep(res + 0.1, res, s);\r\n    float light = min(0.005 / (dist * dist / t + 0.1 * t * t), 2.0);\r\n    float fog = exp(-fogDensity * max(s - fogOffset, 0.0));\r\n    vec3 color = mix(lightColorA, lightColorB, hash3(vec2(row, col)));\r\n    return mask * light * fog * color;\r\n}\r\n\r\nvec3 addSign(vec3 color, vec3 pos, float side, vec2 id) {\r\n    vec4 signHash = hash4(id);\r\n    float s = step(0.5, signHash.z);\r\n    if ((s - 0.5) * side < 0.1)\r\n        return color;\r\n\r\n    vec2 center = vec2(0.2, -0.4) + vec2(0.6, -0.8) * signHash.xy;\r\n    vec2 p = mix(pos.xz, pos.yz, s);\r\n    float halfWidth = 0.04 + 0.06 * signHash.w;\r\n\r\n    float charCount = floor(1.0 + 8.0 * hash1(id + 0.5));\r\n    if (center.y - p.y > 2.0 * halfWidth * (charCount + 1.0)) {\r\n        center.y -= 2.0 * halfWidth * (charCount + 1.5 + 5.0 * hash1(id + 0.6));\r\n        charCount = floor(2.0 + 12.0 * hash1(id + 0.7));\r\n        id += 0.05;\r\n    }\r\n\r\n    vec3 signColor = mix(signColorA, signColorB, hash3(id + 0.5));\r\n    vec3 outlineColor = mix(signColorA, signColorB, hash3(id + 0.6));\r\n    float flash = 6.0 - 24.0 * hash1(id + 0.8);\r\n    flash *= step(3.0, flash);\r\n    flash = smoothstep(0.1, 0.5, 0.5 + 0.5 * cos(flash * time));\r\n\r\n    vec2 halfSize = vec2(halfWidth, halfWidth * charCount);\r\n    center.y -= halfSize.y;\r\n    float outline = length(max(abs(p - center) - halfSize, 0.0)) / halfWidth;\r\n    color *= smoothstep(0.1, 0.4, outline);\r\n\r\n    vec2 charPos = 0.5 * (p - center + halfSize) / halfWidth;\r\n    vec2 charId = id + 0.05 + 0.1 * floor(charPos);\r\n    float flicker = hash1(charId);\r\n    flicker = step(0.93, flicker);\r\n    flicker = 1.0 - flicker * step(0.96, hash1(charId, time));\r\n\r\n    float affe = -3.5 + 8.0 * noise(id + 6.0 * charPos);\r\n    charPos = fract(charPos);\r\n    affe *= smoothstep(0.0, 0.4, charPos.x) * smoothstep(1.0, 0.6, charPos.x);\r\n    affe *= smoothstep(0.0, 0.4, charPos.y) * smoothstep(1.0, 0.6, charPos.y);\r\n    color = mix(color, signColor, flash * flicker * step(outline, 0.01) * clamp(affe, 0.0, 1.0));\r\n\r\n    outline = smoothstep(0.0, 0.2, outline) * smoothstep(0.5, 0.3, outline);\r\n    return mix(color, outlineColor, flash * outline);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 center = -speed * time * cameraDir.xy;\r\n    vec3 eye = vec3(center, 0.0) - cameraDist * cameraDir;\r\n\r\n    vec3 forward = normalize(cameraDir);\r\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\r\n    vec3 up = cross(right, forward);\r\n    vec2 xy = 2.0 * fragCoord - resolution.xy;\r\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * resolution.y);\r\n\r\n    vec4 res = castRay(eye, ray, center);\r\n    vec3 p = eye + res.x * ray;\r\n\r\n    vec2 block = floor(p.xy);\r\n\tvec3 color = window(p.z - res.y, block);\r\n\r\n    color = addSign(color, vec3(p.xy - block, p.z - res.y), res.z, block);\r\n    color = mix(vec3(0.0), color, abs(res.z));\r\n\r\n    float fog = exp(-fogDensity * max(res.x - fogOffset, 0.0));\r\n    color = mix(fogColor, color, fog);\r\n\r\n    float time = lightSpeed * time;\r\n    color += addLight(eye.xyz, ray.xyz, res.x, time, lightHeight - 0.6);\r\n    color += addLight(eye.yxz, ray.yxz, res.x, time, lightHeight - 0.4);\r\n    color += addLight(vec3(-eye.xy, eye.z), vec3(-ray.xy, ray.z), res.x, time, lightHeight - 0.2);\r\n    color += addLight(vec3(-eye.yx, eye.z), vec3(-ray.yx, ray.z), res.x, time, lightHeight);\r\n\r\n    fragColor = vec4(color, 1.0);\r\n}\r\nvoid main(void) {\r\n\tmainImage(gl_FragColor, gl_FragCoord);\r\n}\r\n\r\n";
/* 19 */   public static String Rings = "/*\r\n * Original shader from: https://www.shadertoy.com/view/MtXfD2\r\n */\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n// glslsandbox uniforms\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n// shadertoy emulation\r\n#define iTime time\r\n#define iResolution resolution\r\n\r\n// --------[ Original ShaderToy begins here ]---------- //\r\n// Created by SHAU - 2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n//-----------------------------------------------------\r\n\r\n#define T iTime * 2.0\r\n#define PI 3.14159265359\r\n#define FAR 50.0 \r\n#define EPS 0.005\r\n\r\n#define FLOOR 1.0\r\n#define ORB 2.0\r\n#define WHITE_GLOW 3.0\r\n#define FLAT_L_BLUE 4.0\r\n#define FLAT_D_BLUE 5.0\r\n#define WALL 6.0\r\n#define BLUE_GLOW 7.0\r\n#define ARCH 8.0\r\n#define ARCH_2 9.0\r\n\r\nvec3 lp = vec3(0.0);\r\n\r\nstruct Scene {\r\n    float t;\r\n    vec3 n;\r\n    float id;\r\n    float wli;\r\n    float bli;\r\n};\r\n\r\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\r\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\r\n\r\nfloat sdTorus(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\r\n    return length(q) - t.y;\r\n}\r\n\r\nfloat sdSphere(vec3 p, float s) {\r\n    return length(p) - s;\r\n}\r\n\r\nfloat fCylinder(vec3 p, float r, float height) {\r\n    p.z *= 0.8;\r\n\tfloat d = length(p.xz) - r;\r\n\td = max(d, abs(p.y) - height);\r\n\treturn d;\r\n}\r\n\r\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\r\n    return dot(o - ro, n) / dot(rd, n);\r\n}\r\n\r\nvec2 nearest(vec2 a, vec2 b){ \r\n    float s = step(a.x, b.x);\r\n    return s * a + (1. - s) * b;\r\n}\r\n\r\nvec4 archway(vec3 rp) {\r\n    float rr = (mod(rp.z, 12.0) - 6.0) > 0.0 ? 1.0 : -1.0;\r\n    rp.xy *= rot(T * 0.2 * rr);\r\n    float a = atan(rp.y, rp.x) / 6.2831853;\r\n    float ia = floor(a * 4.0) / 4.0 * 6.2831853;\r\n    vec3 q = rp;\r\n    q.xy *= rot(ia);\r\n    q.z = mod(q.z, 6.0) - 3.0;\r\n    float t1 = sdTorus(q.xzy, vec2(1.5, 0.15));\r\n    float t2 = sdTorus(q.xzy, vec2(1.5, 0.22));\r\n    float t3 = sdTorus(q.xzy, vec2(1.71, 0.02));\r\n    float t4 = sdTorus(q.xzy - vec3(0.0, -0.22, 0.0), vec2(1.5, 0.05));\r\n    t2 = max(t2, q.y - 0.5); \r\n    t4 = max(t4, q.y - 1.2);\r\n    q = rp;\r\n    q.x = abs(q.x);\r\n    q.z = mod(q.z, 6.0) - 3.0;\r\n    float t5 = sdTorus(q.zyx - vec3(0.0, 0.0, 1.5), vec2(0.26, 0.03));     \r\n    vec2 near = vec2(t1, ARCH);\r\n    near = nearest(near, vec2(t2, WALL));    \r\n    near = nearest(near, vec2(t3, ARCH_2));    \r\n    near = nearest(near, vec2(t4, BLUE_GLOW));    \r\n    near = nearest(near, vec2(t5, WHITE_GLOW));    \r\n    return vec4(near, t4, t5);\r\n}\r\n\r\nvec3 tower1(vec3 rp) {\r\n    rp.x = abs(rp.x);\r\n    rp.z = mod(rp.z, 12.0) - 6.0;\r\n    vec2 core = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.2, 3.0), FLAT_L_BLUE);\r\n    float sh = 2.0 + sin(T * 0.2) * 1.;\r\n    vec2 sleeve = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.3, 3.0), WHITE_GLOW);\r\n    float sleevecut = fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.4, 3.0);\r\n    sleeve.x = max(max(sleeve.x, sh - 0.4 - rp.y), rp.y - sh);\r\n    sleevecut = max(max(sleevecut, sh - 0.3 - rp.y), rp.y - sh + 0.1);\r\n    sleeve.x = max(sleeve.x, -sleevecut);\r\n    vec2 base = vec2(fCylinder(rp - vec3(2.5, 0.0, 0.0), 0.3, 0.5), WALL);\r\n    return vec3(nearest(nearest(base, core), sleeve), sleeve.x);\r\n}\r\n\r\nvec3 tower2(vec3 rp) {\r\n    vec3 q = rp;\r\n    q.x = abs(q.x);\r\n    q.z = mod(q.z, 24.0) - 12.0;\r\n    vec2 near = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 2.0, 1.0), WALL);\r\n    vec2 core = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.2, 6.0), WALL);\r\n    q = rp;\r\n    float rh = sin(T * 0.1) * 1.5;    \r\n    q.y += rh;\r\n    q.x = abs(q.x);\r\n    q.z = mod(q.z, 24.0) - 12.0;\r\n    vec2 ringcore = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.3, 4.2), BLUE_GLOW);\r\n    q.y = mod(q.y, 0.4) - 0.2;\r\n    vec2 rings = vec2(fCylinder(q - vec3(9.0, 0.0, 0.0), 1.8, 0.1), WALL);\r\n    rings.x = max(rings.x, rp.y + rh - 4.4);\r\n    near = nearest(near, core);\r\n    near = nearest(near, rings);\r\n    near = nearest(near, ringcore);    \r\n    return vec3(near, ringcore.x);\r\n}\r\n\r\nvec3 smallorbs(vec3 rp) {\r\n    rp.z = mod(rp.z, 3.0) - 1.5;\r\n    rp.x = abs(rp.x);\r\n    vec2 orb = vec2(sdSphere(rp - vec3(1.2, 0.0, 0.0), 0.2), ORB);\r\n    vec2 torus = vec2(sdTorus(rp - vec3(1.2, 0.0, 0.0), vec2(0.25, 0.02)), WHITE_GLOW);\r\n    return vec3(nearest(orb, torus), torus.x);\r\n}\r\n\r\nvec3 mediumorbs(vec3 rp) {    \r\n    vec3 q = rp;\r\n    q.z = mod(q.z, 6.0) - 3.0;\r\n    q.x = abs(q.x);\r\n    vec2 near = vec2(sdSphere(q - vec3(3.4, 0.0, 0.0), 0.8), ORB);\r\n    vec2 torus = vec2(sdTorus(q - vec3(3.4, 0.0, 0.0), vec2(1.0, 0.03)), WHITE_GLOW);\r\n    torus.x = min(torus.x, sdTorus(q - vec3(1.5, 0.0, 0.0), vec2(0.35, 0.03)));\r\n    float fins = sdSphere(q - vec3(3.4, 0.0, 0.0), 0.9);\r\n    q.y = mod(q.y, 0.1) - 0.05;\r\n    fins = max(fins, q.y - 0.01);    \r\n    vec2 fins1 = vec2(max(fins, rp.y - 0.55), FLAT_L_BLUE);\r\n    fins1 = max(fins1, 0.4 - rp.y);\r\n    vec2 fins2 = vec2(max(fins, rp.y - 0.25), FLAT_D_BLUE);\r\n    fins2 = max(fins2, 0.2 - rp.y);  \r\n    near = nearest(near, torus);\r\n    near = nearest(near, fins1);\r\n    near = nearest(near, fins2);\r\n    return vec3(near, torus.x);\r\n}\r\n\r\nvec3 largeorbs(vec3 rp) {\r\n    vec3 q = rp;\r\n    q.z = mod(q.z - 12.0, 24.0) - 12.0;\r\n    q.x = abs(q.x);\r\n    vec2 near = vec2(sdSphere(q - vec3(16.0, 0.0, 0.0), 6.0), ORB);\r\n    vec2 torus = vec2(sdTorus(q - vec3(16.0, 0.0, 0.0), vec2(6.5, 0.1)), WHITE_GLOW);\r\n    float fins = sdSphere(q - vec3(16.0, 0.0, 0.0), 6.3);\r\n    q.y = mod(q.y, 0.4) - 0.2;\r\n    fins = max(fins, q.y - 0.05);    \r\n    vec2 fins1 = vec2(max(fins, rp.y - 1.8), FLAT_L_BLUE);\r\n    fins1 = max(fins1, 1.1 - rp.y);\r\n    vec2 fins2 = vec2(max(fins, rp.y - 0.7), FLAT_D_BLUE);\r\n    fins2 = max(fins2, 0.3 - rp.y);  \r\n    near = nearest(near, torus);\r\n    near = nearest(near, fins1);\r\n    near = nearest(near, fins2);\r\n    return vec3(near, torus.x);\r\n}\r\n\r\nvec4 map(vec3 rp) {\r\n    vec4 arch = archway(rp);\r\n    vec2 near = arch.xy;\r\n    vec3 tow1 = tower1(rp);\r\n    near = nearest(near, tow1.xy);\r\n    vec3 tow2 = tower2(rp);\r\n    near = nearest(near, tow2.xy);\r\n    vec3 sorbs = smallorbs(rp);\r\n    near = nearest(near, sorbs.xy);\r\n    vec3 morbs =  mediumorbs(rp);\r\n    near = nearest(near, morbs.xy);\r\n    vec3 lorbs = largeorbs(rp);\r\n    near = nearest(near, lorbs.xy);\r\n    float blt = min(tow2.z, arch.z); //blue light\r\n    float wlt = min(sorbs.z, morbs.z); //white light\r\n    wlt = min(wlt, lorbs.z);\r\n    wlt = min(wlt, tow1.z);\r\n    wlt = min(wlt, arch.w);\r\n    return vec4(near, blt, wlt);\r\n}\r\n\r\nvec3 normal(vec3 rp) {\r\n    vec2 e = vec2(EPS, 0);\r\n    float d1 = map(rp + e.xyy).x, d2 = map(rp - e.xyy).x;\r\n    float d3 = map(rp + e.yxy).x, d4 = map(rp - e.yxy).x;\r\n    float d5 = map(rp + e.yyx).x, d6 = map(rp - e.yyx).x;\r\n    float d = map(rp).x * 2.0;\r\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\r\n}\r\n\r\n// Based on original by IQ.\r\n// http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\r\nfloat AO(vec3 rp, vec3 n) {\r\n\r\n    float r = 0.0;\r\n    float w = 1.0;\r\n    float d = 0.0;\r\n\r\n    for (float i = 1.0; i < 5.0; i += 1.0){\r\n        d = i / 5.0;\r\n        r += w * (d - map(rp + n * d).x);\r\n        w *= 0.5;\r\n    }\r\n\r\n    return 1.0 - clamp(r, 0.0, 1.0);\r\n}\r\n\r\n//IQ\r\n//http://www.iquilezles.org/www/articles/fog/fog.htm\r\nvec3 applyFog(vec3  rgb,      // original color of the pixel\r\n              float d, // camera to point distance\r\n              vec3  rayDir,   // camera to point vector\r\n              vec3  sunDir,\r\n              float b)  // sun light direction\r\n{\r\n    //float b = 0.07;\r\n    float fogAmount = 1.0 - exp(-d * b);\r\n    float sunAmount = max(dot(rayDir, sunDir), 0.0);\r\n    vec3  fogColor  = mix(vec3(0.5, 0.3, 0.8), // purple\r\n                          vec3(0.7, 0.7, 1.0), // blue\r\n                          pow(sunAmount, 8.0));\r\n    return mix(rgb, fogColor, fogAmount);\r\n}\r\n\r\nvec4 march(vec3 ro, vec3 rd) {\r\n    \r\n    float t = 0.0;\r\n    float id = 0.0;\r\n    float bli = 0.0;\r\n    float wli = 0.0;\r\n    \r\n    for (int i = 0; i < 96; i++) {\r\n        vec3 rp = ro + rd * t;    \r\n        vec4 scene = map(rp);\r\n        if (scene.x < EPS || t > FAR) {\r\n            id = scene.y;\r\n            break;   \r\n        }\r\n        \r\n        bli += 0.05 / (1.0 + scene.z * scene.z * 30.0) * step(0.0, rp.y);\r\n        wli += 0.05 / (1.0 + scene.w * scene.w * 100.0) * step(0.0, rp.y);\r\n        \r\n        t += scene.x;\r\n    }\r\n    \r\n    return vec4(t, id, bli, wli);\r\n}\r\n\r\nScene drawScene(vec3 ro, vec3 rd) {\r\n    \r\n    float mint = FAR;\r\n    vec3 minn = vec3(0.0);\r\n    float id = 0.0;\r\n    float bli = 0.0;\r\n    float wli = 0.0;\r\n    \r\n    vec3 fo = vec3(0.0, 0.0, 0.0);\r\n    vec3 fn = vec3(0.0, 1.0, 0.0);\r\n    float ft = planeIntersection(ro, rd, fn, fo);\r\n    if (ft > 0.0 && ft < mint) {\r\n        mint = ft;\r\n        minn = fn;\r\n        id = FLOOR;\r\n    }\r\n\r\n    vec4 scene = march(ro, rd);\r\n    if (scene.x > 0.0 && scene.x < mint) {\r\n        if (scene.x < mint) {\r\n            mint = scene.x;\r\n            minn = normal(ro + rd * scene.x);\r\n            id = scene.y;\r\n        }\r\n    }\r\n    \r\n    bli = scene.z;\r\n    wli = scene.w;\r\n\r\n    return Scene(mint, minn, id, wli, bli);\r\n}\r\n\r\nvec2 floorTexture(vec3 rp, float t) {\r\n\r\n    float line = 0.0;\r\n    float cut = 0.0;\r\n        \r\n    //small orbs\r\n    vec3 q = rp;\r\n    q.z = mod(q.z, 3.0) - 1.5;\r\n    q.x = abs(q.x);\r\n    line += smoothstep(0.33, 0.32, length(q.xz - vec2(1.2, 0.0))); \r\n    cut += smoothstep(0.3, 0.29, length(q.xz - vec2(1.2, 0.0)));\r\n                \r\n    //medium orbs and archway\r\n    q = rp;\r\n    q.z = mod(q.z, 6.0) - 3.0;\r\n    q.x = abs(q.x);\r\n    line += smoothstep(1.2, 1.18, length(q.xz - vec2(3.4, 0.0))); \r\n    cut += smoothstep(1.1, 1.08, length(q.xz - vec2(3.4, 0.0)));\r\n    line += smoothstep(0.5, 0.48, length(q.xz - vec2(1.5, 0.0)));\r\n    cut += smoothstep(0.42, 0.41, length(q.xz - vec2(1.5, 0.0)));\r\n        \r\n    //large orbs\r\n    q = rp;\r\n    q.z = mod(q.z - 12.0, 24.0) - 12.0;\r\n    q.x = abs(q.x);\r\n    line += smoothstep(7.6, 7.5, length(q.xz - vec2(16.0, 0.0))); \r\n    cut += smoothstep(7.4, 7.3, length(q.xz - vec2(16.4, 0.0)));\r\n        \r\n    q = rp;\r\n    vec2 grid = fract(vec2(q.x * 0.25, q.z * 0.5));\r\n    float gridline = (smoothstep(0.01, 0.005, grid.x) + smoothstep(0.998, 0.999, grid.x));\r\n    gridline += smoothstep(0.02 + t / FAR * 0.2, 0.01, grid.y) / (t * 1.0);\r\n    \r\n    line = clamp(line + gridline, 0.0, 1.0);\r\n    line /= t * 0.5;\r\n\r\n    return vec2(line, cut);\r\n}\r\n\r\nfloat tex(vec2 uv) {\r\n    vec2 mx = mod(uv, 0.1) - 0.05;     \r\n    float tx = (mx.x * mx.y) > 0.0 ? 1.0 : 0.0;\r\n    tx *= sin(uv.y * 100.0 + T) * 0.6 + 1.0;\r\n    tx *= sin(uv.x * 100.0 + T) * 0.6 + 1.0;\r\n    tx *= step(uv.y, 0.1) + step(-uv.y, -0.2); \r\n    return tx;\r\n}        \r\n\r\nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\r\n \r\n    vec3 pc = vec3(0.0);\r\n    \r\n    vec3 rp = ro + rd * scene.t;\r\n    vec3 ld = normalize(lp - rp);\r\n    float lt = length(lp - rp);\r\n    \r\n    float diff = 1.0;\r\n    float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 64.0);\r\n    float atten = 1.0;\r\n    float fres = 0.0;\r\n    \r\n    if (scene.id == FLOOR) {\r\n        \r\n        vec2 flrTex = floorTexture(rp, scene.t);        \r\n        pc += vec3(0.5, 0.3, 1.0) * clamp(flrTex.x, 0.0, 1.0);\r\n        pc -= clamp(flrTex.y, 0.0, 1.0);\r\n        \r\n    } else if (scene.id == ORB) {\r\n        \r\n        diff = max(dot(ld, scene.n), 0.05);\r\n        spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 32.0);\r\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\r\n        \r\n        pc = vec3(0.1) * diff;\r\n        pc += vec3(1.0) * spec;\r\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\r\n\r\n    } else if (scene.id == WALL) {\r\n\r\n        diff = max(dot(ld, scene.n), 0.05);\r\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\r\n\r\n        pc = vec3(0.1) * diff;\r\n        pc += vec3(1.0) * spec;\r\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\r\n\r\n    } else if (scene.id == ARCH) {\r\n        \r\n        diff = max(dot(ld, scene.n), 0.05);\r\n        fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 4.0);\r\n\r\n        vec3 q = rp;\r\n        float rr = (mod(q.z, 12.0) - 6.0) > 0.0 ? 1.0 : -1.0;\r\n        q.xy *= rot(T * 0.2 * rr);\r\n        float a = atan(q.y, q.x) / 6.2831853;\r\n        a = fract(a * 8.0);\r\n        \r\n        pc = vec3(0.1) * diff;\r\n        pc += vec3(0.6, 0.3, 1.0) * step(a, 0.3) * tex(vec2(length(rp.xy), a));\r\n        pc += vec3(1.0) * spec;\r\n        pc += vec3(0.5, 0.3, 1.0) * fres * diff;\r\n\r\n    } else if (scene.id == WHITE_GLOW) {\r\n        \r\n        diff = max(dot(ld, scene.n), 0.8);\r\n        \r\n        pc = vec3(1.0) * diff;\r\n        \r\n    } else if (scene.id == BLUE_GLOW) {\r\n        \r\n        diff = max(dot(ld, scene.n), 0.8);\r\n\r\n        pc = vec3(0.3, 0.3, 1.0) * diff;\r\n        pc += vec3(1.0) * spec;\r\n\r\n    } else if (scene.id == FLAT_L_BLUE) {\r\n        \r\n        diff = max(dot(ld, scene.n), 0.8);\r\n\r\n        pc = vec3(0.5, 0.8, 1.0) * diff;\r\n        pc += vec3(1.0) * spec;\r\n        \r\n    } else if (scene.id == FLAT_D_BLUE) {\r\n\r\n        diff = max(dot(ld, scene.n), 0.8);\r\n\r\n        pc = vec3(0.3, 0.3, 1.0) * diff;\r\n        pc += vec3(1.0) * spec;\r\n\r\n    } else if (scene.id == ARCH_2) {\r\n        \r\n        diff = max(dot(ld, scene.n), 0.05);\r\n        \r\n        pc = vec3(0.5, 0.3, 1.0);\r\n        pc *= diff;\r\n        pc += vec3(1.0) * spec;\r\n    }\r\n    \r\n    //pc *= AO(rp, scene.n);\r\n    \r\n    return pc;\r\n}\r\n\r\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\r\n\r\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\r\n\r\n    vec3 lookAt = vec3(0.0, 0.0, T * 0.5);\r\n    lp = lookAt + vec3(4.0, 4.0, -2.0);\r\n    ro = lookAt + vec3(0.0, 0.8, -4.0);\r\n    \r\n    float FOV = PI / 3.0;\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \r\n    vec3 up = cross(forward, right);\r\n\r\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    \r\n    vec3 pc = vec3(0.0);\r\n    float mint = FAR;\r\n    \r\n    vec3 ro = vec3(0.0), rd = vec3(0.0);\r\n    setupCamera(fragCoord, ro, rd);\r\n    \r\n    Scene scene = drawScene(ro, rd);\r\n    if (scene.t > 0.0 && scene.t < FAR) {\r\n        mint = scene.t;\r\n        pc = colourScene(ro, rd, scene);\r\n        \r\n        if (scene.id == FLOOR || \r\n            scene.id == ORB || \r\n            scene.id == WALL ||\r\n            scene.id == ARCH) {\r\n            \r\n            float lt = scene.t;\r\n            vec3 rc = vec3(0.5, 0.3, 1.0) * 0.2;\r\n            float ra = 0.1;\r\n            \r\n            vec3 rpb = ro + rd * (scene.t - EPS);\r\n            vec3 rrd = reflect(rd, scene.n);\r\n            Scene refl = drawScene(rpb, rrd);\r\n            \r\n            if (refl.t > 0.0 && refl.t < FAR) {\r\n                rc = colourScene(rpb, rrd, refl); \r\n                lt += refl.t;\r\n                if (refl.id == WHITE_GLOW ||\r\n                    refl.id == BLUE_GLOW) {\r\n                    ra = 0.02;\r\n                } else if (refl.id == FLAT_L_BLUE ||\r\n                           refl.id == FLAT_D_BLUE) {\r\n                    ra = 0.06;\r\n                }\r\n            }\r\n            float rt = 1.0 / (1.0 + lt * lt * ra);\r\n            pc += rc * rt * 0.5;\r\n            pc += vec3(1.0) * refl.wli * rt * 0.5;\r\n        }\r\n    }\r\n\r\n    pc = applyFog(pc, mint, rd, normalize(vec3(2.0, 2.0, 4.0)), 0.01);\r\n\r\n    pc += vec3(1.0) * scene.wli * 0.8;\r\n    pc += vec3(0.3, 0.3, 1.0) * scene.bli;\r\n    \r\n\tfragColor = vec4(pc, 1.0);\r\n    //fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\r\n}\r\n// --------[ Original ShaderToy ends here ]---------- //\r\n\r\nvoid main(void)\r\n{\r\n  mainImage(gl_FragColor, gl_FragCoord.xy);\r\n}";
/* 20 */   public static String SnowCircle = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n#define PI 3.14159265359\r\n#define T (time / .99)\r\n\r\nvec3 hsv2rgb(vec3 c)\r\n{\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 4.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nconst float aoinParam1 = 0.7;\r\n\r\nfloat snow(vec2 uv,float scale)\r\n{\r\n\tfloat w=smoothstep(9.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\r\n\tuv+=(time*aoinParam1)/scale;uv.y+=time*0./scale;uv.x+=sin(uv.y+time*.05)/scale;\r\n\tuv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\r\n\tp=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\r\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\r\n    \treturn k*w;\r\n}\r\n\r\nvoid main( void ) {\r\n\r\n\tvec2 position = (( gl_FragCoord.xy / resolution.xy ) - 0.5);\r\n\tposition.x *= resolution.x / resolution.y;\r\n\t\r\n\tvec3 color = vec3(0.);\r\n\t\r\n\tfor (float i = 0.; i < PI*2.0; i += PI/20.0) {\r\n\t\tvec2 p = position - vec2(cos(i), sin(i)) * 0.15;\r\n\t\tvec3 col = hsv2rgb(vec3((i + T)/(PI*2.0), 1., 1));\r\n\t\tcolor += col * (2./512.) / length(p);\r\n\t}\r\n\r\n\tvec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y); \r\n\tvec3 finalColor=vec3(0);\r\n\tfloat c=smoothstep(1.,0.3,clamp(uv.y*.3+.8,0.,.75));\r\n\tc+=snow(uv,7.);\r\n\tc+=snow(uv,6.);\r\n\tc+=snow(uv,5.);\r\n\tfinalColor=(vec3(c));\t\r\n\tgl_FragColor = (vec4( color, 1.0 ) + vec4(finalColor,1)) / vec4(2, 2, 2, 1);\r\n\r\n}";
/* 21 */   public static String Galaxy = "\r\n// Elevated shader\r\n// https://www.shadertoy.com/view/MdX3Rr by inigo quilez\r\n \r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n \r\n// Processing port by Raphal de Courville.\r\n \r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n \r\n// Type of shader expected by Processing\r\n//#define PROCESSING_COLOR_SHADER\r\n \r\n// Processing specific input\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform vec2 mouse;\r\n \r\n// Layer between Processing and Shadertoy uniforms\r\nvec3 iResolution = vec3(resolution,0.0);\r\nfloat iGlobalTime = time;\r\nvec4 iMouse = vec4(mouse,0.0,0.0); // zw would normally be the click status\r\n \r\n// ------- Below is the unmodified Shadertoy code ----------\r\n// Star Nest by Pablo Romn Andrioli\r\n \r\n// This content is under the MIT License.\r\n \r\n#define iterations 16\r\n#define formuparam 0.9\r\n \r\n#define volsteps 64\r\n#define stepsize 0.1\r\n \r\n#define zoom   1.0\r\n#define tile   1.0\r\n#define speed  0.005 \r\n \r\n#define brightness 0.005\r\n#define darkmatter 0.5\r\n#define distfading 0.9\r\n#define saturation 0.5\r\n \r\n \r\n\r\n\r\nvec2 uv;\r\n\r\n\r\nconst vec2 ch_size  = vec2(1.0, 2.0);              // character size (X,Y)\r\nconst vec2 ch_space = ch_size + vec2(1.0, 1.0);    // character distance Vector(X,Y)\r\nconst vec2 ch_start = vec2 (ch_space.x * -6., 2.); // start position\r\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\r\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\r\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\r\n\r\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\r\n\r\n/* 16 segment display...Akin to LED Display.\r\n\r\nSegment bit positions:\r\n  __2__ __1__\r\n |\\    |    /|\r\n | \\   |   / |\r\n 3  11 10 9  0\r\n |   \\ | /   |\r\n |    \\|/    |\r\n  _12__ __8__\r\n |           |\r\n |    /|\\    |\r\n 4   / | \\   7\r\n | 13 14  15 |\r\n | /   |   \\ |\r\n  __5__|__6__\r\n\r\n15 12 11 8 7  4 3  0\r\n |  | |  | |  | |  |\r\n 0000 0000 0000 0000\r\n\r\nexample: letter A\r\n\r\n   12    8 7  4 3210\r\n    |    | |  | ||||\r\n 0001 0001 1001 1111\r\n\r\n binary to hex -> 0x119F\r\n*/\r\n\r\n#define n0 ddigit(0x22FF);\r\n#define n1 ddigit(0x0281);\r\n#define n2 ddigit(0x1177);\r\n#define n3 ddigit(0x11E7);\r\n#define n4 ddigit(0x5508);\r\n#define n5 ddigit(0x11EE);\r\n#define n6 ddigit(0x11FE);\r\n#define n7 ddigit(0x2206);\r\n#define n8 ddigit(0x11FF);\r\n#define n9 ddigit(0x11EF);\r\n\r\n#define A ddigit(0x119F);\r\n#define B ddigit(0x927E);\r\n#define C ddigit(0x007E);\r\n#define D ddigit(0x44E7);\r\n#define E ddigit(0x107E);\r\n#define F ddigit(0x101E);\r\n#define G ddigit(0x807E);\r\n#define H ddigit(0x1199);\r\n#define I ddigit(0x4466);\r\n#define J ddigit(0x4436);\r\n#define K ddigit(0x9218);\r\n#define L ddigit(0x0078);\r\n#define M ddigit(0x0A99);\r\n#define N ddigit(0x8899);\r\n#define O ddigit(0x00FF);\r\n#define P ddigit(0x111F);\r\n#define Q ddigit(0x80FF);\r\n#define R ddigit(0x911F);\r\n#define S ddigit(0x8866);\r\n#define T ddigit(0x4406);\r\n#define U ddigit(0x00F9);\r\n#define V ddigit(0x2218);\r\n#define W ddigit(0xA099);\r\n#define X ddigit(0xAA00);\r\n#define Y ddigit(0x4A00);\r\n#define Z ddigit(0x2266);\r\n#define _ ch_pos.x += ch_space.x;\r\n#define s_dot     ddigit(0);\r\n#define s_minus   ddigit(0x1100);\r\n#define s_plus    ddigit(0x5500);\r\n#define s_greater ddigit(0x2800);\r\n#define s_less    ddigit(0x8200);\r\n#define s_sqrt    ddigit(0x0C02);\r\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\r\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\r\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\r\n\r\nfloat dseg(vec2 p0, vec2 p1)\r\n{\r\n\tvec2 dir = normalize(p1 - p0);\r\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\r\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \r\n}\r\n\r\nbool bit(int n, int b)\r\n{\r\n\treturn mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\r\n}\r\n\r\nfloat d = 1e6;\r\n\r\nvoid ddigit(int n)\r\n{\r\n\tfloat v = 1e6;\t\r\n\tvec2 cp = uv - ch_pos;\r\n\tif (n == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\r\n\tif (bit(n,  0)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\r\n\tif (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\r\n\tif (bit(n,  2)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\r\n\tif (bit(n,  3)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\r\n\tif (bit(n,  4)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\r\n\tif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\r\n\tif (bit(n,  6)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\r\n\tif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\r\n\tif (bit(n,  8)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\r\n\tif (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\r\n\tif (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\r\n\tif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\r\n\tif (bit(n, 12)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\r\n\tif (bit(n, 13)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\r\n\tif (bit(n, 14)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\r\n\tif (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\r\n\tch_pos.x += ch_space.x;\r\n\td = min(d, v);\r\n}\r\nmat2 rotate(float a)\r\n{\r\n\tfloat c = cos(a);\r\n\tfloat s = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\nvec3 hsv2rgb_smooth( in vec3 c )\r\n{\r\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\r\n\r\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\r\n\r\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\r\n}\r\n\r\nvec3 message(vec3 icol)\r\n{\r\n\tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\r\n\tuv.x += 0.5+sin(time+uv.y*0.7)*0.5;\r\n\tuv.y += ((0.5+sin(time+uv.x*0.4)*0.5)*1.9)-0.7;\r\n\tch_pos = ch_start;\r\n\r\n\t\t\t nl1\r\n\t         //S M O K E _ B E R T\r\n\t\t\r\n\tvec3 color = mix(ch_color, icol, 1.0- (0.08 / d*2.0));  // shading\r\n\treturn color;\r\n\t\r\n}\r\n\r\n\r\nvoid main(void)\r\n{\r\n\t//get coords and direction\r\n\tvec2 _uv=gl_FragCoord.xy/iResolution.xy-.5;\r\n\t_uv.y*=iResolution.y/iResolution.x;\r\n\tvec3 dir=vec3(_uv*zoom,1.);\r\n\tfloat time=iGlobalTime*speed+.25;\r\n \r\n\t//mouse rotation\r\n\tfloat a1=.0+iMouse.x/iResolution.x*0.;\r\n\tfloat a2=.0+iMouse.y/iResolution.y*0.;\r\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\r\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\r\n\tdir.xz*=rot1;\r\n\tdir.xy*=rot2;\r\n\tvec3 from=vec3(5.5,.5,0.5);\r\n\tfrom+=vec3(time*2.,time,-2.);\r\n\tfrom.xz*=rot1;\r\n\tfrom.xy*=rot2;\r\n\t\r\n\t//volumetric rendering\r\n\tfloat s=0.1,fade=1.;\r\n\tvec3 v=vec3(0.);\r\n\tfor (int r=0; r<volsteps; r++) {\r\n\t\tvec3 p=from+s*dir*.5;\r\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\r\n\t\tfloat pa,a=pa=0.;\r\n\t\tfor (int i=0; i<iterations; i++) { \r\n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\r\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\r\n\t\t\tpa=length(p);\r\n\t\t}\r\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\r\n\t\ta*=a*a; // add contrast\r\n\t\tif (r>5) fade*=1.-dm; // dark matter, don't render near\r\n\t\t//v+=vec3(dm,dm*.5,0.);\r\n\t\tv+=fade;\r\n\t\tv+=vec3(s*s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\r\n\t\tfade*=distfading; // distance fading\r\n\t\ts+=stepsize;\r\n\t}\r\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\r\n\tvec3 col = vec3(v*.01);\r\n\t\r\n\tvec2 aspect = resolution.xy / resolution.y;\r\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 1.70;\r\n\tuv*=14.0;\r\n\t\r\n\tcol = clamp(col,vec3(0.0),vec3(1.0));\r\n\t\r\n\tgl_FragColor = vec4(message(col),1.);\t\r\n\t\r\n}\r\n\r\n";
/* 22 */   public static String RedNight = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n// glslsandbox uniforms\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform vec2 mouse;\r\n\r\n// shadertoy globals\r\nfloat iTime = 0.0;\r\nvec3  iResolution = vec3(0.0);\r\nvec4 iMouse = vec4(0.0);\r\n\r\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord);\r\nvoid main(void) {\r\n    iTime = time;\r\n    iResolution = vec3(resolution, 0.0);\r\n    iMouse = vec4(mouse, 0.0, 0.0);\r\n\r\n    mainImage(gl_FragColor, gl_FragCoord.xy);\r\n}\r\n\r\n/*\r\n * Original shader from: https://www.shadertoy.com/view/XsX3DS\r\n */\r\n\r\nfloat rand(vec2 p){\r\n\tp+=.2127+p.x+.3713*p.y;\r\n\tvec2 r=4.789*sin(789.123*(p));\r\n\treturn fract(r.x*r.y);\r\n}\r\n\r\nfloat sn(vec2 p){\r\n\tvec2 i=floor(p-.5);\r\n\tvec2 f=fract(p-.5);\r\n\tf = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n\tfloat rt=mix(rand(i),rand(i+vec2(1.,0.)),f.x);\r\n\tfloat rb=mix(rand(i+vec2(0.,1.)),rand(i+vec2(1.,1.)),f.x);\r\n\treturn mix(rt,rb,f.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\r\n\tuv+=iMouse.xy/ iResolution.xy;\r\n\t\r\n\tvec2 p=uv.xy*vec2(3.,4.3);\r\n\tfloat f =\r\n\t.5*sn(p)\r\n\t+.25*sn(2.*p)\r\n\t+.125*sn(4.*p)\r\n\t+.0625*sn(8.*p)\r\n\t+.03125*sn(16.*p)+\r\n\t.015*sn(32.*p)\r\n\t;\r\n\t\r\n\tfloat newT = iTime*0.4 + sn(vec2(iTime*1.))*0.1;\r\n\tp.x-=iTime*0.2;\r\n\t\r\n\tp.y*=1.3;\r\n\tfloat f2=\r\n\t.5*sn(p)\r\n\t+.25*sn(2.04*p+newT*1.1)\r\n\t-.125*sn(4.03*p-iTime*0.3)\r\n\t+.0625*sn(8.02*p-iTime*0.4)\r\n\t+.03125*sn(16.01*p+iTime*0.5)+\r\n\t.018*sn(24.02*p);\r\n\t\r\n\tfloat f3=\r\n\t.5*sn(p)\r\n\t+.25*sn(2.04*p+newT*1.1)\r\n\t-.125*sn(4.03*p-iTime*0.3)\r\n\t+.0625*sn(8.02*p-iTime*0.5)\r\n\t+.03125*sn(16.01*p+iTime*0.6)+\r\n\t.019*sn(18.02*p);\r\n\t\r\n\tfloat f4 = f2*smoothstep(0.0,1.,uv.y);\r\n\t\r\n\tvec3 clouds = mix(vec3(-0.4,-0.4,-0.15),vec3(1.4,1.4,1.3),f4*f);\r\n\tfloat lightning = sn((f3)+vec2(pow(sn(vec2(iTime*4.5)),6.)));\r\n\r\n\tlightning *= smoothstep(0.0,1.,uv.y+0.5);\r\n\r\n\tlightning = smoothstep(0.76,1.,lightning);\r\n\tlightning=lightning*2.;\r\n\t\r\n\tvec2 moonp = vec2(0.5,0.8);\r\n\tfloat moon = smoothstep(0.95,0.956,1.-length(uv-moonp));\r\n\tvec2 moonp2 = moonp + vec2(0.015, 0);\r\n\tmoon -= smoothstep(0.93,0.956,1.-length(uv-moonp2));\r\n\tmoon = clamp(moon, 0., 1.);\r\n\tmoon += 0.3*smoothstep(0.80,0.956,1.-length(uv-moonp));\r\n\r\n\tclouds+= pow(1.-length(uv-moonp),1.7)*0.3;\r\n\r\n\tclouds*=0.8;\r\n\tclouds += lightning + moon +0.2;\r\n\r\n\tfloat ground = smoothstep(0.07,0.075,f*(p.y-0.98)+0.01);\r\n\t\r\n\tvec2 newUV = uv;\r\n\tnewUV.x-=iTime*0.3;\r\n\tnewUV.y+=iTime*3.;\r\n\tfloat strength = sin(iTime*0.5+sn(newUV))*0.1+0.15;\r\n\t\r\n\tfloat rain = sn( vec2(newUV.x*20.1, newUV.y*40.1+newUV.x*400.1-20.*strength ));\r\n\tfloat rain2 = sn( vec2(newUV.x*45.+iTime*0.5, newUV.y*30.1+newUV.x*200.1 ));\t\r\n\train = strength-rain;\r\n\train+=smoothstep(0.2,0.5,f4+lightning+0.1)*rain;\r\n\train += pow(length(uv-moonp),1.)*0.1;\r\n\train+=rain2*(sin(strength)-0.4)*2.;\r\n\train = clamp(rain, 0.,0.5)*0.5;\r\n\t\r\n\tfloat tree = 0.;\r\n\tvec2 treeUV = uv;\r\n\r\n\t{\r\n\t\tfloat atree = abs(atan(treeUV.x-59.-85.5,3.-treeUV.y*25.+5.));\r\n\t\tatree +=rand(treeUV.xy*vec2(0.001,1.))*atree;\r\n\t\ttree += clamp(atree, 0.,1.)*0.33;\r\n\t}\r\n\t{\r\n\t\tfloat atree = abs(atan(treeUV.x*65.-65.5,3.-treeUV.y*19.+4.));\r\n\t\tatree +=rand(treeUV.xy*vec2(0.001,1.))*atree;\r\n\t\ttree += clamp(atree, 0.,1.)*0.33;\r\n\t}\r\n\t{\r\n\t\tfloat atree = abs(atan(treeUV.x*85.-91.5,3.-treeUV.y*21.+4.));\r\n\t\tatree +=rand(treeUV.xy*vec2(0.001,1.))*atree;\r\n\t\ttree += clamp(atree, 0.,1.)*0.34;\r\n\t}\r\n\ttree = smoothstep(0.6,1.,tree);\r\n\t\r\n\t\r\n\tvec3 painting = tree*ground*(clouds + rain)+clamp(rain*(strength-0.1),0.,1.);\r\n\t\r\n\tfloat r=1.-length(max(abs(fragCoord.xy / iResolution.xy*2.-1.)-.5,0.)); \r\n\tpainting*=r;\r\n\t\r\n\tpainting *= vec3(1.5, 0.2, 0.3);\r\n\t\r\n\tfragColor = vec4(painting, 7.);\r\n}";
/* 23 */   public static String Ball = "/*\r\n * Original shader from: https://www.shadertoy.com/view/Wsy3zm\r\n */\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n// glslsandbox uniforms\r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n// shadertoy emulation\r\nfloat iTime = 0.0;\r\n#define iResolution resolution\r\n\r\n// Protect glslsandbox uniform names\r\n#define time        stemu_time\r\n\r\n// --------[ Original ShaderToy begins here ]---------- //\r\n/*\r\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\r\nThe shader was made using Bonzomatic.\r\nYou can find the original shader here: http://lezanu.fr/LiveCode/TheOrbOfGreatPower.glsl\r\n*/\r\n\r\nfloat time=0.0;\r\n\r\nmat2 rot(float a) {\r\n  float ca=cos(a);\r\n  float sa=sin(a);\r\n  return mat2(ca,sa,-sa,ca);  \r\n}\r\n\r\nfloat smin(float a, float b, float h) {\r\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\r\n  return mix(a,b,k) - k*(1.0-k)*h;\r\n}\r\n\r\nvec3 smin(vec3 a, vec3 b, float h) {\r\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\r\n  return mix(a,b,k) - k*(1.0-k)*h;\r\n}\r\n\r\nfloat rnd(float a) {\r\n  return fract(sin(a*452.655)*387.521);  \r\n}\r\n\r\nvec3 rnd3(float a) {\r\n  return fract(sin(a*vec3(845.652,257.541,289.675))*vec3(354.852,685.527,947.544));\r\n}\r\n\r\nvec3 rndcol(float a) {\r\n  vec3 r=rnd3(a);\r\n  //r/=dot(r,vec3(0.33));\r\n  r/=max(r.x, max(r.y,r.z));\r\n  return r;\r\n}\r\n\r\nfloat rnd(vec2 uv) {\r\n  return fract(dot(sin(uv*357.542+uv.yx*685.427),vec2(925.674)));\r\n  \r\n}\r\n\r\nvec3 kifs(vec3 p, float t, float t3) {\r\n  \r\n  vec3 bp=p;\r\n  float s=0.0 + smoothstep(0.0,1.0,fract(t3))*10.0;\r\n  for(int i=0; i<3; ++i) {\r\n    float t2 = t + float(i);\r\n    p.xz *= rot(t2);\r\n    p.xy *= rot(t2*0.7);\r\n    \r\n    // using smooth minimum on all 3 channels to make a \"smooth\" symmetry\r\n    p=smin(p, -p, -3.0);\r\n    //p=abs(p);\r\n    p-=s;// + sin(t*0.2-length(p)*1.0) * 0.5;\r\n    s*=0.7;\r\n  }\r\n  \r\n  \r\n  return p;\r\n}\r\n\r\nfloat exspeed = 0.25;\r\nfloat explode(vec3 p, float t, float offset) {\r\n  \r\n  // rotating and swirling in all directions\r\n  p.xz *= rot(p.y*0.09+t*0.15);\r\n  p.xy *= rot(p.z*0.052+t*0.18);\r\n  \r\n  float t1 = t * exspeed + offset;\r\n  vec3 p2 = kifs(p, t*0.1, t1);\r\n  vec3 p3 = kifs(p+vec3(3,2,1), t*0.13, t1);\r\n  \r\n  float fade = 1.0-pow(fract(t1),10.0);\r\n  \r\n  float d1 = length(p2)-1.5*fade;\r\n  d1=min(d1, length(p2.xz)-0.8*fade);\r\n  float d2 = length(p3)-1.4*fade;\r\n  d2=min(d2, length(p3.xz)-0.8*fade);\r\n  \r\n  return smin(d1,d2, -1.0);\r\n}\r\n\r\nfloat box(vec3 p, float r) {\r\n  p=abs(p)-r;\r\n  return max(p.x, max(p.y,p.z));\r\n}\r\n\r\nfloat box(vec2 p, float r) {\r\n  p=abs(p)-r;\r\n  return max(p.x, p.y);\r\n}\r\n\r\nfloat cyl(vec2 p, float r) {\r\n  return length(p)-r;\r\n}\r\n\r\n\r\nfloat at=0.0;\r\nfloat at2=0.0;\r\nbool metal=false;\r\nvec3 pos1 = vec3(0);\r\nvec3 pos2 = vec3(0);\r\nfloat map(vec3 p) {\r\n  \r\n  #if 0\r\n  // having fun with repetition and rotations\r\n  float t=time*0.2;\r\n  p.z += t*15;\r\n  p.x += sin(p.z*0.037+t)*33;\r\n  p.y += sin(p.z*0.027+t*0.7)*23;\r\n  p.xy *= rot(p.z*0.02+t*5.0);\r\n  //p.xz *= rot(p.y*0.015+t*0.7);\r\n  \r\n  float dist = 35;\r\n  p.z = (fract(p.z/dist-0.5)-0.5)*dist;\r\n  p=abs(p);\r\n  #endif\r\n    \r\n  // we compute two explosion at the same time\r\n  // offseted in time so one explosion start when the other disappear\r\n  float m1 = explode(p+pos1, time, 0.0);\r\n  float m2 = explode(p+pos2, time, 0.5);\r\n  \r\n  at += 0.8/(2.0+abs(m1));\r\n  at2 += 0.8/(2.0+abs(m2));\r\n  \r\n  float m3 = min(abs(m1),abs(m2));\r\n  \r\n  vec3 bp=p;\r\n  bp += smoothstep(-0.5,0.5,sin(p.yzx*1.0))*0.2;\r\n  float other = (length(bp)-15.0)*0.8;\r\n  \r\n  #if 0\r\n  // Tried to add a \"cage\" but it's less great\r\n  for(int i=0;i<2;++i) {\r\n    float t3=time*0.1+i;\r\n    p.xz *= rot(0.7);\r\n    p.xy *= rot(0.7);\r\n    p=abs(p)-5.6;\r\n    //p=smin(p, -p, -2.0)-3;\r\n  }\r\n  float s=0.5;\r\n  other=min(other, cyl(p.xy, s));\r\n  other=min(other, cyl(p.yz, s));\r\n  other=min(other, cyl(p.xz, s));\r\n  //other=smin(other, length(bp)-25,-10);\r\n  other=max(other, length(bp)-35);\r\n  \r\n  //other = max(-(length(p)-8.5),sqrt(abs(p.x)+abs(p.y)+abs(p.z))-1.2*3);\r\n  #endif \r\n  \r\n  metal=other<m3;\r\n  \r\n  return min(m3, other);\r\n}\r\n\r\nvoid cam(inout vec3 p) {\r\n  \r\n  float t=time*0.3;\r\n  p.xz *= rot(t);\r\n  p.xy *= rot(t*1.2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n  time = mod(iTime, 300.0);\r\n    \r\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\r\n  uv -= 0.5;\r\n  uv /= vec2(iResolution.y / iResolution.x, 1);\r\n  \r\n  // pick a random position for each explosion\r\n  pos1 = (rnd3(floor(time*exspeed))-0.5) * 20.0;\r\n  pos2 = (rnd3(floor(time*exspeed+0.5)+37.2)-0.5) * 20.0;\r\n  \r\n  float fade1 = 1.0-pow(fract(time*exspeed),10.0);\r\n  float fade2 = 1.0-pow(fract(time*exspeed+0.5),10.0);\r\n  \r\n  // pick a random color for each explosion\r\n  vec3 c1 = rndcol(floor(time*exspeed)+17.3);\r\n  vec3 c2 = rndcol(floor(time*exspeed+0.5)+37.5);\r\n  \r\n  vec3 s=vec3(0,0,-60);\r\n  vec3 r=normalize(vec3(-uv, 1));\r\n  \r\n  cam(s);\r\n  cam(r);\r\n  \r\n  float dither = mix(1.0, rnd(uv), 0.1);\r\n  \r\n  vec2 off=vec2(0.01,0);\r\n  \r\n  vec3 col=vec3(0);\r\n  vec3 p=s;\r\n    // this is done to ensure the loop is not unrolled, so compile time doesnt explode\r\n  const float iterationcount = 90.0;\r\n  for(float i=0.0; i<iterationcount; ++i) {\r\n    // we use the absolute value of the distance field, so we can also march inside the surface\r\n    float d=abs(map(p))*dither;\r\n    if(d<0.01) {\r\n      if(metal) {\r\n        vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\r\n        r=reflect(r,n);\r\n      }\r\n      // instead of breaking when we find a surface, we continue to march forward with a slight offset\r\n      d=0.1;\r\n      //break;\r\n    }\r\n    col += pow(at * 0.010,3.0) * c1 * fade1;\r\n    col += pow(at2 * 0.010,3.0) * c2 * fade2;\r\n    p+=r*d;\r\n  }\r\n    \r\n  col *= 3.0;\r\n  \r\n  // the dark souls\r\n  //col *= smoothstep(0.0,0.01,length(uv)-0.25);\r\n  \r\n  // bloom to white on primary colors\r\n  col += max(vec3(0),col.yzx-1.0);\r\n  col += max(vec3(0),col.zxy-1.0);\r\n  \r\n  //col=smoothstep(0,1,col);\r\n  col=1.0-exp(-col);\r\n  col=pow(col, vec3(1.0));\r\n  \r\n  \r\n  //col += pow(1-i/101.0,6) * 1.5;\r\n  \r\n  fragColor = vec4(col, 1);\r\n}\r\n// --------[ Original ShaderToy ends here ]---------- //\r\n\r\n#undef time\r\n\r\nvoid main(void)\r\n{\r\n    iTime = time;\r\n    mainImage(gl_FragColor, gl_FragCoord.xy);\r\n}";
/* 24 */   public static String Thunder = "// Lightning\r\n// By: Brandon Fogerty\r\n// bfogerty at gmail dot com \r\n// xdpixel.com\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n\r\nfloat Hash( vec2 p)\r\n{\r\n     vec3 p2 = vec3(p.xy,1.0);\r\n    return fract(sin(dot(p2,vec3(37.1,61.7, 12.4)))*3758.5453123);\r\n}\r\n\r\nfloat noise(in vec2 p)\r\n{\r\n    vec2 i = floor(p);\r\n     vec2 f = fract(p);\r\n     f *= f*(3.0-2.0*f);\r\n    return mix(mix(Hash(i + vec2(0.,0.)), Hash(i + vec2(1.,0.)),f.x),\r\n               mix(Hash(i + vec2(0.,1.)), Hash(i + vec2(1.,1.)),f.x),\r\n               f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n     float v = 0.0;\r\n     v += noise(p*1.0) * .75;\r\n     v += noise(p*3.)  * .50;\r\n     v += noise(p*9.)  * .250;\r\n     v += noise(p*27.)  * .125;\r\n     return v;\r\n}\r\n\r\nvoid main( void ) \r\n{\r\n\r\n\tvec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\r\n\tuv.x *= resolution.x/resolution.y; uv.y -= 0.25;\r\n\r\n\tfloat timeVal = time * 0.1;\r\n\r\n\tvec3 finalColor = vec3( 0.0 );\r\n\tfor( int i=0; i < 20; ++i )\r\n\t{\r\n\t\tfloat indexAsFloat = float(i);\r\n\t\tfloat amp = 10.0 + (indexAsFloat*500.0);\r\n\t\tfloat period = 2.0 + (indexAsFloat+2.0);\r\n\t\tfloat thickness = mix( 0.9, 1.0, noise(uv*indexAsFloat) );\r\n\t\tfloat t = abs( 1.0 / (sin(uv.y + fbm( uv + timeVal * period )) * amp) * thickness );\r\n\t\t\r\n\t\t\r\n\t\tfinalColor +=  t * vec3( .3, 0.95, 2.5 );\r\n\t}\r\n\t\r\n\tgl_FragColor = vec4( finalColor, 1.0 );\r\n\r\n}";
/* 25 */   public static String Wassersaeule = "// original shader https://www.shadertoy.com/view/lttfDH\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform vec2 resolution;\r\nuniform float time;\r\n\r\n// replace shadertoy uniforms with glslsandbox\r\n#define R resolution\r\n#define T time\r\n\r\n// toggle for psychedelic madness\r\n#define ENABLE_COLOR_CYCLE 1\r\n\r\n// FabriceNeyret2 \r\n#define hue(v)  (.5 + cos(6.3 * (v) + vec4(0, 23, 21, 0)))\r\n\r\nint id = -1;\r\n\r\nmat2 rotate(float a) {\r\n\tfloat c = cos(a),\r\n\t\ts = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\nfloat random(in vec2 st) {\r\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\r\n}\r\n\r\nfloat noise(vec2 p) {\r\n\tvec2 i = ceil(p);\r\n    vec2 f = fract(p);\r\n    vec2 u = f * f * (3. - 2. * f);\r\n   \tfloat a = random(i);\r\n    float b = random(i + vec2(1., 0.));\r\n    float c = random(i + vec2(0., 1.));\r\n    float d = random(i + vec2(1., 1.));\r\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\r\n}\r\n\r\nfloat fbm(in vec2 p) { \r\n\tfloat s = .0;\r\n\tfloat m = .0;\r\n\tfloat a = .5;\t\r\n\tfor(int i = 0; i < 8; i++) {\r\n\t\ts += a * noise(p);\r\n\t\tm += a;\r\n\t\ta *= .5;\r\n\t\tp *= 2.;\r\n\t}\r\n\treturn s / m;\r\n}\r\n\r\nvec3 renderFractal(vec2 uv) {\r\n\r\n    vec3 color = vec3(0.);\r\n    vec2 p = uv;\r\n\t\r\n    // per channel iters\r\n    float t = T;\r\n    for (int c = 0; c < 3; c++) {\r\n    \r\n        t += .1; // time offset per channel\r\n        \r\n\t\tfloat l = 0.;\r\n        float s = 1.;\r\n        for (int i = 0; i < 8; i++) {\r\n            // from Kali's fractal iteration\r\n            p = abs(p) / dot(p, p);\r\n            p -= s;\r\n            p *= rotate(t * .5);\r\n            s *= .8;\r\n            l += (s  * .08) / length(p);\r\n        }\r\n        color[c] += l;\r\n    \r\n    }\r\n\r\n\treturn color;\r\n\r\n}\r\n\r\nfloat map(vec3 p) {\r\n\t\r\n    float m = 1000.;\r\n    \r\n    vec3 q = p;\r\n    float k = fbm(q.xz + fbm(q.xz + T *2.));\r\n   \t\r\n    q.y += .1;\r\n    float d = dot(q, vec3(0., 1., 0.)) + k;\r\n\td = min(5. - d, d);\r\n    if (d < m) { \r\n        m = d;\r\n        id = 1;\r\n    }\r\n    \r\n    q = p;\r\n    q.xz = mod(q.xz + 2., 4.) - 2.;\r\n    d = min(d, length(q.xz) - .5);\r\n    if (d < m) { \r\n        m = d;\r\n        id = 2;\r\n    }\r\n    \r\n    return m;\r\n}\r\n\r\nvec3 render(vec3 ro, vec3 rd) {\r\n\r\n    vec3 col = vec3(0.);\r\n\tvec3 p;\r\n    \r\n\tfloat t = 0.;\r\n\tfor (int i = 0; i < 256; i++) {\r\n\t\tp = ro + rd * t;\r\n\t\tfloat d = map(p);\r\n\t\tif (d < .001 || t > 50.) break;\r\n\t\tt += .5 * d;\r\n#if ENABLE_COLOR_CYCLE \r\n        col += .02 * hue(d * .5 + T * .4).rgb;\r\n#else\r\n        col += .02 * hue(d).rgb;\r\n#endif\r\n\t}\r\n\t\r\n    vec3 tex =  renderFractal(fract(.1 * p.xz) - .5);\r\n    if (id == 1) col += tex / (1. + t * t * .5);\r\n    if (id == 2) col += abs(.1 / sin(10. * p.y + T)) * vec3(0., 1., 1.);\r\n    \r\n\treturn col;\r\n\r\n}\r\n\r\nvoid mainImage(out vec4 O, vec2 I) {\r\n\r\n    vec2 uv = (2. * I - R)\r\n        / R.y;\r\n\tvec3 col = vec3(0.);\r\n\t\r\n\tvec3 ro = vec3(2., 1., T * 2.);\r\n\tvec3 rd = vec3(uv, 1.);\r\n\t\r\n    vec3 pc = render(ro, rd);\r\n    \r\n    O = vec4(pc, 1.);\r\n}\r\n\r\nvoid main() {\r\n\tmainImage(gl_FragColor, gl_FragCoord.xy);\r\n}\r\n";
/* 26 */   public static String Green = "\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n \r\nuniform float time;\r\nuniform vec2 mouse;\r\nuniform vec2 resolution;\r\n \r\n// by srtuss, 2013\r\n// was trying to find some sort of \"mechanical\" fractal for texture/heightmap\r\n// generation, but then i ended up with this.\r\n \r\n// rotate position around axis\r\nvec2 rotate(vec2 p, float a)\r\n{\t\r\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\r\n}\r\n \r\n// 1D random numbers\r\nfloat rand(float n)\r\n{\r\n    return fract(sin(n));\r\n}\r\n \r\n// 2D random numbers\r\nvec2 rand2(in vec2 p)\r\n{\r\n\treturn fract(vec2(sin(p.x * 1.32 + p.y * 54.077), cos(p.x * 91.32 + p.y * 9.077)));\r\n}\r\n \r\n// 1D noise\r\nfloat noise1(float p)\r\n{\r\n\tfloat fl = floor(p);\r\n\tfloat fc = fract(p);\r\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\r\n}\r\n \r\n// voronoi distance noise, based on iq's articles\r\nfloat voronoi(in vec2 x)\r\n{\r\n\tvec2 p = floor(x);\r\n\tvec2 f = fract(x);\r\n\t\r\n\tvec2 res = vec2(8.0);\r\n\tfor(int j = -1; j <= 1; j ++)\r\n\t{\r\n\t\tfor(int i = -1; i <= 1; i ++)\r\n\t\t{\r\n\t\t\tvec2 b = vec2(i, j);\r\n\t\t\tvec2 r = vec2(b) - f + rand2(p + b);\r\n\t\t\t\r\n\t\t\t// chebyshev distance, one of many ways to do this\r\n\t\t\tfloat d = max(abs(r.x), abs(r.y));\r\n\t\t\t\r\n\t\t\tif(d < res.x)\r\n\t\t\t{\r\n\t\t\t\tres.y = res.x;\r\n\t\t\t\tres.x = d;\r\n\t\t\t}\r\n\t\t\telse if(d < res.y)\r\n\t\t\t{\r\n\t\t\t\tres.y = d;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn res.y - res.x;\r\n}\r\n \r\n \r\n#define flicker (noise1(time * 2.0) * 0.9 + 0.5)\r\n \r\nvoid main(void)\r\n{\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tuv = (uv - 0.5) * 2.0;\r\n\tvec2 suv = uv;\r\n\tuv.x *= resolution.x / resolution.y;\r\n\t\r\n\t\r\n\tfloat v = 0.0;\r\n\t\r\n\t// that looks highly interesting:\r\n\tv = 1.0 - length(uv) * 0.7;\r\n\t\r\n\t\r\n\t// a bit of camera movement\r\n\tuv *= 0.8 + sin(time * 0.6) * 0.01;  //\r\n\tuv = rotate(uv, cos(0.0668) * (time * 0.0075));\r\n\tuv += time * 0.01;\r\n\t\r\n\t\r\n\t// add some noise octaves\r\n\tfloat a = 0.6, f = 1.0;\r\n\t\r\n\tfor(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though\r\n\t{\t\r\n\t\tfloat v1 = voronoi(uv * f + 1.0);\r\n\t\tfloat v2 = 0.0;\r\n\t\t\r\n\t\t// make the moving electrons-effect for higher octaves\r\n\t\tif(i > 0)\r\n\t\t{\r\n\t\t\t// of course everything based on voronoi\r\n\t\t\tv2 = voronoi(uv * f * 1.5 + 5.0 + time);\r\n\t\t\t\r\n\t\t\tfloat va = 0.0, vb = 0.0;\r\n\t\t\tva = 1.0 - smoothstep(0.0, 0.1, v1);\r\n\t\t\tvb = 1.0 - smoothstep(0.0, 0.08, v2);\r\n\t\t\tv += a * pow(va * (0.5 + vb), 2.0);\r\n\t\t}\r\n\t\t\r\n\t\t// make sharp edges\r\n\t\tv1 = 1.0 - smoothstep(0.0, 0.2, v1);\r\n\t\t\r\n\t\t// noise is used as intensity map\r\n\t\tv2 = a * (noise1(v1 * 5.5 + 0.1));\r\n\t\t\r\n\t\t// octave 0's intensity changes a bit\r\n\t\tif(i == 0)\r\n\t\t\tv += v2 * flicker;\r\n\t\telse\r\n\t\t\tv += v2;\r\n\t\t\r\n\t\tf *= 3.0;\r\n\t\ta *= 0.7;\r\n\t}\r\n \r\n\t// slight vignetting\r\n\tv *= exp(-0.36 * length(suv)) * 0.8;\r\n\t\r\n\t// use texture channel0 for color? why not.\r\n\t//vec3 cexp = texture2D(iChannel0, uv * 0.001).xyz * 3.0 + texture2D(iChannel0, uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);\r\n\t\r\n\t// old blueish color set\r\n\tvec3 cexp = vec3(20.0, 2.0, 10.0);\r\n\t\tcexp *= 1.3;\r\n \r\n\tvec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\r\n\t\r\n\tgl_FragColor = vec4(col, 1.0);\r\n}";
/* 27 */   public static String Acora = "#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n \r\n \r\nuniform float time;\r\nuniform vec2 resolution;\r\n\r\n#define mouse vec2(sin(time)/48., cos(time)/48.)\r\n#define iterations 14\r\n#define formuparam2 0.79\r\n \r\n#define volsteps 5\r\n#define stepsize 0.390\r\n \r\n#define zoom 0.900\r\n#define tile   0.850\r\n#define speed2  500.0 \r\n#define brightness 0.003\r\n#define darkmatter 0.400\r\n#define distfading 0.560\r\n#define saturation 0.800\r\n\r\n\r\n#define transverseSpeed zoom*2.0\r\n#define cloud 0.11 \r\n\r\n \r\nfloat triangle(float x, float a) { \r\n\tfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;\r\n\treturn output2;\r\n}\r\n \r\nfloat field(in vec3 p) {\t\r\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = 0.;\r\n\tfloat prev = 0.;\r\n\tfloat tw = 0.;\t\r\n\r\n\tfor (int i = 0; i < 6; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(time*0.7 + 2.0), -1.1+0.3*cos(time*0.3));\r\n\t\tfloat w = exp(-float(i) / 7.);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0., 5. * accum / tw - .7);\r\n}\r\n\r\n\r\n\r\nvoid main() {   \r\n     \tvec2 uv2 = 2. * gl_FragCoord.xy / vec2(512) - 1.;\r\n\tvec2 uvs = uv2 * vec2(512)  / 512.;\r\n\t\r\n\tfloat time2 = time;               \r\n        float speed = speed2;\r\n        speed = .01 * cos(time2*0.02 + 3.1415926/4.0);          \r\n\t\t\r\n    \tfloat formuparam = formuparam2;\r\n\t\r\n    \t\t\r\n\tvec2 uv = uvs;\t\t       \r\n\t\r\n\tfloat a_xz = 0.9;\r\n\tfloat a_yz = -.6;\r\n\tfloat a_xy = 0.9 + time*0.08;\t\r\n\t\r\n\tmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\t\r\n\tmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\t\t\r\n\tmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\r\n\t\r\n\r\n\tfloat v2 =1.0;\t\r\n\tvec3 dir=vec3(uv*zoom,1.); \r\n\tvec3 from=vec3(0.0, 0.0,0.0);                               \r\n        from.x -= 5.0*(mouse.x-0.5);\r\n        from.y -= 5.0*(mouse.y-0.5);\r\n               \r\n               \r\n\tvec3 forward = vec3(0.,0.,1.);   \r\n\tfrom.x += transverseSpeed*(1.0)*cos(0.01*time) + 0.001*time;\r\n\tfrom.y += transverseSpeed*(1.0)*sin(0.01*time) +0.001*time;\r\n\tfrom.z += 0.003*time;\t\r\n\t\r\n\tdir.xy*=rot_xy;\r\n\tforward.xy *= rot_xy;\r\n\tdir.xz*=rot_xz;\r\n\tforward.xz *= rot_xz;\t\r\n\tdir.yz*= rot_yz;\r\n\tforward.yz *= rot_yz;\r\n\t\r\n\tfrom.xy*=-rot_xy;\r\n\tfrom.xz*=rot_xz;\r\n\tfrom.yz*= rot_yz;\r\n\t\r\n\tfloat zooom = (time2-3311.)*speed;\r\n\tfrom += forward* zooom;\r\n\tfloat sampleShift = mod( zooom, stepsize );\r\n\t \r\n\tfloat zoffset = -sampleShift;\r\n\tsampleShift /= stepsize;\r\n\t\r\n\t\r\n\tfloat s=0.24;\r\n\tfloat s3 = s + stepsize/2.0;\r\n\tvec3 v=vec3(0.);\r\n\tfloat t3 = 0.0;\t\r\n\t\r\n\tvec3 backCol2 = vec3(0.);\r\n\tfor (int r=0; r<volsteps; r++) {\r\n\t\tvec3 p2=from+(s+zoffset)*dir;\r\n\t\tvec3 p3=from+(s3+zoffset)*dir;\r\n\t\t\r\n\t\tp2 = abs(vec3(tile)-mod(p2,vec3(tile*2.)));\r\n\t\tp3 = abs(vec3(tile)-mod(p3,vec3(tile*2.)));\t\t\r\n\t\t#ifdef cloud\r\n\t\tt3 = field(p3);\r\n\t\t#endif\r\n\t\t\r\n\t\tfloat pa,a=pa=0.;\r\n\t\tfor (int i=0; i<iterations; i++) {\r\n\t\t\tp2=abs(p2)/dot(p2,p2)-formuparam;\r\n\t\t\t\r\n\t\t\tfloat D = abs(length(p2)-pa);\r\n\t\t\ta += i > 7 ? min( 12., D) : D;\r\n\t\t\tpa=length(p2);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ta*=a*a;\r\n\t\t\r\n\t\tfloat s1 = s+zoffset;\r\n\t\t\r\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\t\t\r\n\t\t\t\r\n\t\tv+=fade;\r\n\t       \t\r\n\r\n\t\t\r\n\t\tif( r == 0 )\r\n\t\t\tfade *= (1. - (sampleShift));\r\n\t\t\r\n\t\tif( r == volsteps-1 )\r\n\t\t\tfade *= sampleShift;\r\n\t\tv+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade;\r\n\t\t\r\n\t\tbackCol2 += mix(.4, 1., v2) * vec3(1.8 * t3 * t3 * t3, 1.4 * t3 * t3, t3) * fade;\r\n\r\n\t\t\r\n\t\ts+=stepsize;\r\n\t\ts3 += stepsize;\t\t\r\n\t}\r\n\t\t       \r\n\tv=mix(vec3(length(v)),v,saturation);\t\r\n\r\n\tvec4 forCol2 = vec4(v*.01,1.);\t\r\n\t#ifdef cloud\r\n\tbackCol2 *= cloud;\r\n\t#endif\t\r\n\tbackCol2.b *= 1.8;\r\n\tbackCol2.r *= 0.05;\t\r\n\t\r\n\tbackCol2.b = 0.5*mix(backCol2.g, backCol2.b, 0.8);\r\n\tbackCol2.g = 0.0;\r\n\tbackCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(time*0.01) + 1.0));\t\r\n\tgl_FragColor = forCol2 + vec4(backCol2, 1.0);\r\n}\r\n";
/* 28 */   public static String RainbowColor = "#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\r\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\r\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\r\n\r\nfloat noise(vec3 p){\r\n    vec3 a = floor(p);\r\n    vec3 d = p - a;\r\n    d = d * d * (3.0 - 2.0 * d);\r\n\r\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\r\n    vec4 k1 = perm(b.xyxy);\r\n    vec4 k2 = perm(k1.xyxy + b.zzww);\r\n\r\n    vec4 c = k2 + a.zzzz;\r\n    vec4 k3 = perm(c);\r\n    vec4 k4 = perm(c + 1.0);\r\n\r\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\r\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\r\n\r\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\r\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\r\n\r\n    return o4.y * d.y + o4.x * (1.0 - d.y);\r\n}\r\nfloat field(in vec3 p,float s) {\r\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = s/4.;\r\n\tfloat prev = 0.;\r\n\tfloat tw = 0.;\r\n\tfor (int i = 0; i < 26; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\r\n\t\tfloat w = exp(-float(i) / 7.);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0., 5. * accum / tw - .7);\r\n}\r\n\r\n// Less iterations for second layer\r\nfloat field2(in vec3 p, float s) {\r\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = s/4.;\r\n\tfloat prev = 0.;\r\n\tfloat tw = 0.;\r\n\tfor (int i = 0; i < 18; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\r\n\t\tfloat w = exp(-float(i) / 7.);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0., 5. * accum / tw - .7);\r\n}\r\n\r\nvec3 nrand3( vec2 co )\r\n{\r\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\r\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\r\n\tvec3 c = mix(a, b, 0.5);\r\n\treturn c;\r\n}\r\n\r\n\r\nvoid main( ) {\r\n    vec2 uv = 2. * gl_FragCoord.xy / resolution.xy - 1.;\r\n\tvec2 uvs = uv * resolution.xy / max(resolution.x, resolution.y);\r\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\r\n\tp += .2 * vec3(sin(time / 16.), sin(time / 12.),  sin(time / 128.));\r\n\t\r\n\tfloat freqs[4];\r\n\t//Sound\r\n\tfreqs[0] = noise(vec3( 0.01*100.0, 0.25 ,time/10.0) );\r\n\tfreqs[1] = noise(vec3( 0.07*100.0, 0.25 ,time/10.0) );\r\n\tfreqs[2] = noise(vec3( 0.15*100.0, 0.25 ,time/10.0) );\r\n\tfreqs[3] = noise(vec3( 0.30*100.0, 0.25 ,time/10.0) );\r\n\r\n\tfloat t = field(p,freqs[2]);\r\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\r\n\t\r\n    //Second Layer\r\n\tvec3 p2 = vec3(uvs / (4.+sin(time*0.11)*0.2+0.2+sin(time*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\r\n\tp2 += 0.25 * vec3(sin(time / 16.), sin(time / 12.),  sin(time / 128.));\r\n\tfloat t2 = field2(p2,freqs[3]);\r\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\r\n\t\r\n\t\r\n\t//Let's add some stars\r\n\t//Thanks to http://glsl.heroku.com/e#6904.0\r\n\tvec2 seed = p.xy * 2.0;\t\r\n\tseed = floor(seed * resolution.x);\r\n\tvec3 rnd = nrand3( seed );\r\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\r\n\t\r\n\t//Second Layer\r\n\tvec2 seed2 = p2.xy * 2.0;\r\n\tseed2 = floor(seed2 * resolution.x);\r\n\tvec3 rnd2 = nrand3( seed2 );\r\n\tstarcolor += vec4(pow(rnd2.y,40.0));\r\n\t\r\n\tgl_FragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;\r\n}";
/*    */   
/*    */   public static void draw() {}
/*    */ }


/* Location:              C:\Users\emlin\Desktop\BetterCraft.jar!\me\nzxter\bettercraft\mods\shader\BackgroundShader1.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */